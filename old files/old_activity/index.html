<!doctype html> <html lang=en > <a id=top ></a> <link rel=icon  href="/assets/favicon.png"> <link rel=icon  type="image/x-icon" href="/assets/favicon.png"> <link rel=icon  type="image/png" href="/assets/favicon.png"/> <link rel=icon  href="/assets/main img.jpg"> <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { response = await fetch(url); fig = await response.json(); Plotly.newPlot(div, fig); }; </script> <link rel=stylesheet  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_hyde.css"> <link rel=icon  href="/assets/favicon.png"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <title>Attività</title> <!-- <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { console.log("url: ",url); console.log("div: ",div); response = await fetch(url); fig = await response.json(); if (typeof fig.config === 'undefined') { fig["config"]={} } delete fig.layout.width delete fig.layout.height fig["layout"]["autosize"] = true fig["config"]["autosizable"] = true fig["config"]["responsive"] = true fig.config["scrollZoom"] = false delete fig.config.staticPlot delete fig.config.displayModeBar delete fig.config.doubleClick delete fig.config.showTips Plotly.newPlot(div, fig); }; </script> --> <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { response = await fetch(url); fig = await response.json(); Plotly.newPlot(div, fig); }; </script> <!-- <a class=backToTopBtn  title="back to top // torna in cima" href="#top"> <span class=backToTopBtn-icon >^</span> </a> --> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <!-- <h1><a href="/">Hyde</a></h1> <p class=lead >A two-column theme.</p> --> <h1><a href="/">Eccoci.<img style="display: block; margin: 0 auto; margin-bottom: 20px"; width=170 ; src="/assets/main img.jpg" alt="main img"/></a></h1> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/">Home</a> <a class="sidebar-nav-item " href="/activity/">Attività</a> <a class="sidebar-nav-item " href="/uni/">Uni</a> <a class="sidebar-nav-item " href="/portfolio/">Portfolio</a> </nav> <a href="https://www.youtube.com/channel/UC1_68R2Kv1htcZ1It5il7CQ" target=_blank rel=noopener> <i class="fab fa-youtube big-icon"></i></a> <a href="https://www.instagram.com/divergentissimo/" target=_blank rel=noopener> <i class="fab fa-instagram big-icon"></i></a> <a href="https://www.linkedin.com/in/federico-angelo-mor/" target=_blank rel=noopener> <i class="fab fa-linkedin big-icon"></i></a> <a href="https://github.com/federicomor" target=_blank rel=noopener> <i class="fab fa-github big-icon"></i></a> </div> </div> <div class="content container"> <a class=backToTopBtn  title="back to top // torna in cima" href="#top"> <span class=backToTopBtn-icon >∧</span> </a> <div class=franklin-content > <h1 id="attività"><a href="#attività" class=header-anchor >Attività</a></h1> <p>L&#39;idea è che ad ogni articoletto di &quot;divulgazione matematica&quot; dovrebbe essere associato un video che lo racconta/analizza/risolve in dettaglio. Se non c&#39;è è perché devo ancora registrarlo :&#41;</p> <p>Presto inoltre ristrutturerò la pagina, il suo layout, in modo che ogni problema abbia la sua pagina dedicata, per poi scriverci meglio tutto all&#39;interno.</p> <p><div class=franklin-toc ><ol><li><a href="#problemi">Problemi</a><ol><li><a href="#ipercubi_in_n_dimensioni">Ipercubi in N dimensioni</a><li><a href="#paradosso_dei_compleanni">Paradosso dei compleanni</a><li><a href="#tennis_tie-break_probability">Tennis tie-break probability</a><li><a href="#strategia_ottimale_per_appuntamenti">Strategia ottimale per appuntamenti</a><li><a href="#traffic_problem">Traffic problem</a><li><a href="#polygon_problem">Polygon problem</a><li><a href="#modi_per_salire_una_scala">Modi per salire una scala</a><li><a href="#condivisione_equa_di_diversi_contributi">Condivisione equa di diversi contributi</a><li><a href="#triello_probabilistico">Triello probabilistico</a><li><a href="#testando_la_resistenza_delle_uova">Testando la resistenza delle uova</a><li><a href="#babbo_natale_e_le_dismutazioni">Babbo Natale e le dismutazioni</a></ol></ol></div> <button id=toc-button >//</button> <div id=toc-container > <div id=toc > <div class=franklin-toc ><ol><li><a href="#problemi">Problemi</a><ol><li><a href="#ipercubi_in_n_dimensioni">Ipercubi in N dimensioni</a><li><a href="#paradosso_dei_compleanni">Paradosso dei compleanni</a><li><a href="#tennis_tie-break_probability">Tennis tie-break probability</a><li><a href="#strategia_ottimale_per_appuntamenti">Strategia ottimale per appuntamenti</a><li><a href="#traffic_problem">Traffic problem</a><li><a href="#polygon_problem">Polygon problem</a><li><a href="#modi_per_salire_una_scala">Modi per salire una scala</a><li><a href="#condivisione_equa_di_diversi_contributi">Condivisione equa di diversi contributi</a><li><a href="#triello_probabilistico">Triello probabilistico</a><li><a href="#testando_la_resistenza_delle_uova">Testando la resistenza delle uova</a><li><a href="#babbo_natale_e_le_dismutazioni">Babbo Natale e le dismutazioni</a></ol></ol></div> </div> </div> </p> <h2 id=problemi ><a href="#problemi" class=header-anchor >Problemi</a></h2> <h3 id=ipercubi_in_n_dimensioni ><a href="#ipercubi_in_n_dimensioni" class=header-anchor >Ipercubi in N dimensioni</a></h3> <p></p> <iframe width="80%" style="aspect-ratio:16/9; margin: auto;" src="https://www.youtube.com/embed/NjdqSz4iva0?rel=0"> </iframe> <p></p> <p>Finché si lavora con quadrati o cubi è tutto molto easy, possiamo anche disegnarli per studiarli e per capire, ad esempio, quanti vertici, lati e facce abbiano. Salendo di dimensione occorre invece arrivarci per vie traverse, e qui vediamo come ci si può arrivare sfruttando anche un po&#39; di calcolo combinatorio.</p> <p>Queste sarebbero le conclusioni a cui si arriva: detto \(N\) il numero di dimensioni in cui lavoriamo &#40;quindi considerando un \(N\)-cubo&#41;, abbiamo che</p> \[ \begin{align*} \#\text{(vertici)} &= 2^{N}\\ \#\text{(lati)} &= \dfrac{\#\text{(vertici)}\cdot N}{2}\\ \#\text{(facce piane)} &= \dfrac{\#\text{(vertici)}\cdot \binom{N}{2}}{2^2}\\ \#\text{(facce di dimensione $k$)} &= \dfrac{\#\text{(vertici)}\cdot \binom{N}{k}}{2^k} \quad k\in\{3,\ldots,N-1\} \end{align*} \] <p>dove \(\binom{N}{k}\) è il coefficiente binomiale di \(N\) su \(k\), quindi \(\frac{N!}{k!(N-k)!}\). Le facce piane sono quelle classiche, mentre quelle di dimensioni maggiori hanno senso in dimensioni maggiori. Per esempio, uno può chiedersi da quante facce 5-cubiche è formato un 7-cubo, o domande ancora peggiori.</p> <h3 id=paradosso_dei_compleanni ><a href="#paradosso_dei_compleanni" class=header-anchor >Paradosso dei compleanni</a></h3> <p></p> <iframe width="80%" style="aspect-ratio:16/9; margin: auto;" src="https://www.youtube.com/embed/u9nr7_sGnm4?rel=0"> </iframe> <p></p> \[ \begin{align*} \mathbb{P} \begin{pmatrix} \text{in un gruppo di $n$ persone almeno }\\\text{due hanno lo stesso compleanno} \end{pmatrix}&= 1-\frac{365!}{(365-n)!365^n}\\ \mathbb{P}\begin{pmatrix} \text{in un gruppo di $n$ persone almeno}\\\text{un'altra ha \textit{il tuo} stesso compleanno} \end{pmatrix}&= 1-\left(\frac{364}{365}\right)^n \end{align*} \] <p>Questo problema è noto come &quot;paradosso dei compleanni&quot; perché per la prima probabilità si arriva al 50&#37; già con solo 23 persone, che in effetti sembrano molte poche. Nel video è quindi spiegato come ricavare quei valori e anche come interpretarli, per capire perché quel risultato un po&#39; controintuitivo abbia in realtà senso.</p> <p>Sempre nel caso della prima probabilità si raggiuge davvero l&#39;1 &#40;ovvero la certezza che si realizzi l&#39;evento&#41; ovviamente solo con 366 persone &#40;per il principio della piccionaia, volendo essere precisi, in modo che vengono forzate le date di due persone ad essere uguali&#41;. Gli &quot;uno&quot; prima di lui presenti nel plot che ora segue sono quindi solo dovuti ad approssimazioni del grafico &#40;che non riporta tutti i decimali&#41; che diventano poi approssimazioni numeriche &#40;in cui cioè i calcoli saturano la precisione disponibile per la rappresentazione dei numeri decimali in un computer&#41; da 295 persone in poi.</p> <p>Infatti i valori precisi calcolati dal codice sarebbero:</p> <pre><code class=language-julia >⋮
n&#61;80: 0.9999143319493134946903219036781801337436248827650357978945842589451803561427634
n&#61;81: 0.9999331085083680711965527193103598304573509358576306915067301747928120589059932
n&#61;82: 0.9999479529215795403282766363949101146572264815988140175011270401127633554227453
⋮
n&#61;258: 0.9999999999999999999999999999999999999999999999999999998264153107735258302391866
n&#61;259: 0.9999999999999999999999999999999999999999999999999999999491135294596363392755936
n&#61;260: 0.999999999999999999999999999999999999999999999999999999985222011295127265652638
⋮
n&#61;293: 0.9999999999999999999999999999999999999999999999999999999999999999999999999999309
n&#61;294: 0.9999999999999999999999999999999999999999999999999999999999999999999999999999827
n&#61;295: 1.0
⋮</code></pre> <p><pre><code class=language-julia >using Plots

p1&#40;n&#41; &#61; 1 - factorial&#40;big&#40;365&#41;&#41; / &#40;factorial&#40;big&#40;365-n&#41;&#41; * big&#40;365&#41;^n&#41;
p1_values &#61; p1.&#40;1:365&#41;
plot&#40;p1_values,title&#61;&quot;p1 values&quot;&#41;

p2&#40;n&#41; &#61; 1 - &#40;big&#40;364/365&#41;^n&#41;
p2_values &#61; p2.&#40;1:2000&#41;
plot&#40;p2_values,title&#61;&quot;p2 values&quot;&#41;</code></pre> <div id=fdpbcu  style=""></div> <script> graphDiv = document.getElementById("fdpbcu"); plotlyPromise = PlotlyJS_json(graphDiv, '/assets/scripts/output/paradosso_compleanni_1.json'); </script> <div id=fdplfw  style=""></div> <script> graphDiv = document.getElementById("fdplfw"); plotlyPromise = PlotlyJS_json(graphDiv, '/assets/scripts/output/paradosso_compleanni_2.json'); </script> </p> <h3 id=tennis_tie-break_probability ><a href="#tennis_tie-break_probability" class=header-anchor >Tennis tie-break probability</a></h3> <p></p> <iframe width="80%" style="aspect-ratio:16/9; margin: auto;" src="https://www.youtube.com/embed/ra9LTkehYk4?rel=0"> </iframe> <p></p> <p>Vediamo come calcolare la probabilità di vincere un tiebreak a tennis, quindi una super applicazione della matematica &#40;statistica e probabilità&#41; ad un problema reale.</p> <p><pre><code class=language-julia >using Plots
using Distributions 

# 1  2  3  4  5  6  7  8  9  10 11 12
# A  B  B  A  A  B  B  A  A  B  B  A
function ptiebreak&#40;a::Real,b::Real&#41;
    p70 &#61; &#40;pdf&#40;Binomial&#40;3,a&#41;,3&#41; * pdf&#40;Binomial&#40;3,b&#41;,3&#41;&#41;*b 
    # batte B al 7mo turno
    p71 &#61; sum&#40;&#91;pdf&#40;Binomial&#40;3,a&#41;,i&#41; * pdf&#40;Binomial&#40;4,b&#41;,6-i&#41; for i in 2:3&#93;&#41;*a 
    # batte A all&#39;8vo turno
    p72 &#61; sum&#40;&#91;pdf&#40;Binomial&#40;4,a&#41;,i&#41; * pdf&#40;Binomial&#40;4,b&#41;,6-i&#41; for i in 2:4&#93;&#41;*a 
    # batte A al 9no turno
    p73 &#61; sum&#40;&#91;pdf&#40;Binomial&#40;5,a&#41;,i&#41; * pdf&#40;Binomial&#40;4,b&#41;,6-i&#41; for i in 2:5&#93;&#41;*b 
    # batte B al 10mo turno 
    p74 &#61; sum&#40;&#91;pdf&#40;Binomial&#40;5,a&#41;,i&#41; * pdf&#40;Binomial&#40;5,b&#41;,6-i&#41; for i in 1:5&#93;&#41;*b 
    # batte B al 11mo turno
    p75 &#61; sum&#40;&#91;pdf&#40;Binomial&#40;5,a&#41;,i&#41; * pdf&#40;Binomial&#40;6,b&#41;,6-i&#41; for i in 0:5&#93;&#41;*a
    # batte A al 12mo turno
    p66 &#61; sum&#40;&#91;pdf&#40;Binomial&#40;6,a&#41;,i&#41; * pdf&#40;Binomial&#40;6,b&#41;,6-i&#41; for i in 0:6&#93;&#41;
    pda66 &#61; a*b/&#40;1-a-b&#43;2*a*b&#41; 
    
    ptot &#61; p70&#43;p71&#43;p72&#43;p73&#43;p74&#43;p75&#43;p66*pda66
    @assert 0&lt;&#61;ptot&lt;&#61;1
    return ptot
end

aa &#61; range&#40;0.01,0.99, step&#61;0.01&#41;
bb &#61; range&#40;0.01,0.99, step&#61;0.01&#41;
p &#61; surface&#40;aa, bb, ptiebreak,camera&#61;&#40;25,20&#41;&#41;
xlabel&#33;&#40;&quot;a values&quot;&#41;
ylabel&#33;&#40;&quot;b values&quot;&#41;

contourf&#40;aa, bb, ptiebreak&#41;
xlabel&#33;&#40;&quot;a values&quot;&#41;
ylabel&#33;&#40;&quot;b values&quot;&#41;</code></pre> <div id=fdpgib  style=""></div> <script> graphDiv = document.getElementById("fdpgib"); plotlyPromise = PlotlyJS_json(graphDiv, '/assets/scripts/output/tennis_surface.json'); </script> <div id=fdpees  style=""></div> <script> graphDiv = document.getElementById("fdpees"); plotlyPromise = PlotlyJS_json(graphDiv, '/assets/scripts/output/tennis_contourf.json'); </script> </p> <h3 id=strategia_ottimale_per_appuntamenti ><a href="#strategia_ottimale_per_appuntamenti" class=header-anchor >Strategia ottimale per appuntamenti</a></h3> <p>Vediamo ora una delle domande più cruciali nella vita sentimentale: <em>quante persone dovremmo frequentare prima di scegliere quella con cui stabilizzarci per qualcosa di più serio?</em></p> <p>È una domanda difficile, ma la matematica può aiutarci trovando una risposta: il 37&#37;. In pratica, di tutte le persone con cui possibilmente potremmo fissare un appuntamento, dovremmo conoscere ma scartare a priori le prime 37&#37;, dalla nostra &quot;scelta definitiva&quot;, e poi continuare gli appuntamenti fino ad accasarci con la prima persona che incontriamo e che valutiamo migliore di quelle viste prima; o altrimenti aspettare l&#39;ultima persona, se questa scelta migliore non si presenta.</p> <p>Perché è una buona strategia?<sup id="fnref:1"><a href="#fndef:1" class=fnref >[1]</a></sup> Ovviamente non conviene scegliere la prima persona che incontriamo, per quanto possa sembrare promettente, perché qualcuno di meglio potrebbe apparire più tardi. D&#39;altra parte, non vogliamo nemmeno essere troppo esigenti, perché una volta che rifiutiamo qualcuno molto probabilmente non vorrà tornare da noi qualora ci ripensassimo. Ma quindi perché il 37&#37;? L&#39;idea è solo di massimizzare le probabilità.</p> <img src="/assets/img/date4_cut.jpeg" alt=""> <p>Più precisamente: supponiamo di volerci &quot;sistemare&quot; entro un certo periodo. Definiamo \(N\) come il numero di partner che stimiamo di poter incontrare in questo periodo, e che quindi costituiscono i nostri candidati moglie/marito. Supponiamo di poter assegnare a ogni partner un punteggio da 1 a \(N\) per definire il nostro grado di compatibilità<sup id="fnref:2"><a href="#fndef:2" class=fnref >[2]</a></sup>. In questo gruppo ci sarà anche la nostra anima gemella, <em>quella giusta</em>, che chiamiamo \(X\) e che avrà quindi il punteggio massimo. Vorremo ora definire una strategia che massimizzi la probabilità di trovarla.</p> <p>Dato \(N\), quindi, vorremo capire come bilanciare il rischio tra &quot;scegliere un partner iniziale magari non perfetto&quot; e &quot;scartare partner che invece col senno di poi valeva la pena scegliere&quot;, e quindi vorremo definire \(M\) come la soglia di persone che delimita i gruppi <em>scarto</em> vs <em>ci penso</em>. La nostra strategia, come sopra anticipato, consiste allora nell&#39;incontrare – ma scartare – le prime \(M\) persone, in modo solo da farci un&#39;idea della qualità delle proposte, e poi scegliere, tra i partner degli appuntamenti successivi, la prima che è migliore della persona migliore incontrata nel gruppo scartato; o altrimenti l&#39;ultima se non si presenta nessuna con questo requisito. Calcolando l&#39;\(M\) ottimale, in funzione di \(N\), risulterà che </p> \[ M = \frac{N}{e} \approx 0.37 \cdot N \] <p>ovvero \(M\) deve essere circa il 37&#37; di \(N\).</p> <p><table class=fndef  id="fndef:1"> <tr> <td class=fndef-backref ><a href="#fnref:1">[1]</a> <td class=fndef-content >&quot;buona strategia&quot; dal punto di vista del risolvere il problema in modo matematico, ma poi naturalmente nelle relazioni umane non ha troppo senso ragionare solo in questi termini razionali. Se per esempio il primo appuntamento ci colpisce non è che dobbiamo rifiutare quel partner solo perché la matematica dice di farlo. </table> <table class=fndef  id="fndef:2"> <tr> <td class=fndef-backref ><a href="#fnref:2">[2]</a> <td class=fndef-content >l&#39;assegnazione corretta di questi punteggi esiste ma è a noi ignota, ovviamente, perché il punteggio da assegnare a ogni partner lo sapremo esattamente solo una volta fatti tutti gli appuntamenti. Solo una volta conosciuti tutti potremmo allora dire &quot;lei era la migliore&quot; &#40;punteggio \(N\)&#41;, &quot;quest&#39;altra la seconda migliore&quot; &#40;punteggio \(N-1\)&#41;, ecc. Durante il percorso invece possiamo solo fare confronti del tipo &quot;lei era peggiore di quella vista prima&quot;, &quot;quest&#39;altra era migliore di tutte le altre viste finora&quot;, ecc, ovvero confronti relativi. </table> <pre><code class=language-julia >using Random
Random.seed&#33;&#40;42&#41;

function M_strategy_score&#40;partners,M,verbose&#61;0&#41;
    N &#61; length&#40;partners&#41;
    @assert N &gt;&#61; M&#43;1
    partners_not_discarded &#61; partners&#91;M&#43;1:end&#93;
    best_score_of_discarded &#61; maximum&#40;partners&#91;1:M&#93;&#41; # il punteggio migliore tra le persone del gruppo iniziale
    
    available_scores &#61; max.&#40;partners_not_discarded .- best_score_of_discarded,0&#41;
    
    out &#61; findfirst&#40;u -&gt; u&#33;&#61;0, available_scores&#41;
    chosen_index &#61; isnothing&#40;out&#41; ? lastindex&#40;partners_not_discarded&#41; : out
    score_out &#61; partners_not_discarded&#91;chosen_index&#93;
    found_soul_mate &#61; score_out&#61;&#61;N # se score&#61;&#61;N abbiamo trovato la nostra anima gemella

    if verbose&#61;&#61;1
        println&#40;&quot;We discarded &#36;M partners &#40;from &#36;N partners&#41;.&quot;&#41;
        println&#40;&quot;The best score there was &#36;best_score_of_discarded.&quot;&#41;
        printstyled&#40;partners&#91;1:M&#93;; color&#61;:yellow&#41;
        printstyled&#40;partners&#91;M&#43;1:end&#93;; color&#61;:green&#41;
        println&#40;&quot;\nIn the end we selected partner #&#36;&#40;chosen_index&#43;M&#41; of score &#36;score_out.&quot;&#41;
        println&#40;found_soul_mate&#61;&#61;1 ? &quot;We&quot; : &quot;We didnt have&quot;, &quot; found our soulmate.\n&quot;&#41;
    end
    
    return found_soul_mate # return 0 or 1
end 

M &#61; 5
partners &#61; shuffle&#40;1:20&#41;
M_strategy_score&#40;partners,M,1&#41;

# optimal strategy should be discarding M&#61;N/ℯ partners
N &#61; 100
simulations &#61; 30_000
values_tested &#61; &#91;&quot;2&quot;,&quot;ℯ&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;&#93;
M_values &#61; round.&#40;Int64,&#91;N/2 N/ℯ N/3 N/4 N/5 N/6 N/7&#93;&#41;
scores &#61; zeros&#40;length&#40;M_values&#41;&#41;

for sim in 1:simulations
    local partners &#61; shuffle&#40;1:N&#41;
    for i in 1:length&#40;M_values&#41;
        scores&#91;i&#93; &#43;&#61; M_strategy_score&#40;partners,M_values&#91;i&#93;&#41;
    end
end
scores ./&#61; simulations
println&#40;&quot;Testing on N &#61; &#36;N.&quot;&#41;
for i in 1:length&#40;M_values&#41;
    println&#40;&quot;Using M &#61; &#36;&#40;M_values&#91;i&#93;&#41; &#40;that is N/&#36;&#40;values_tested&#91;i&#93;&#41;&#41; we got score &#61; &#36;&#40;scores&#91;i&#93;&#41;&quot;&#41;
end     
    println&#40;&quot;Where score is the probability of having found our soulmate.&quot;&#41;

using Plots
plot&#40;bar&#40;scores&#41;,xticks&#61;&#40;1:length&#40;values_tested&#41;,&quot;N&quot;.*&quot;/&quot;.*values_tested&#41;&#41;</code></pre> <div id=fdplka  style=""></div> <script> graphDiv = document.getElementById("fdplka"); plotlyPromise = PlotlyJS_json(graphDiv, '/assets/scripts/output/date_strategy.json'); </script> <pre><code class="plaintext code-output">We discarded 5 partners (from 20 partners).
The best score there was 19.
[19, 10, 2, 1, 6][12, 9, 8, 11, 15, 7, 4, 17, 20, 16, 5, 3, 14, 18, 13]
In the end we selected partner #14 of score 20.
We found our soulmate.

Testing on N = 100.
Using M = 50 (that is N/2) we got score = 0.3525
Using M = 37 (that is N/ℯ) we got score = 0.37606666666666666
Using M = 33 (that is N/3) we got score = 0.37456666666666666
Using M = 25 (that is N/4) we got score = 0.3532666666666667
Using M = 20 (that is N/5) we got score = 0.3268333333333333
Using M = 17 (that is N/6) we got score = 0.3065333333333333
Using M = 14 (that is N/7) we got score = 0.28196666666666664
Where score is the probability of having found our soulmate.
</code></pre></p> <iframe src="https://www.desmos.com/calculator/7xjua3xllw" width="100%" style="aspect-ratio:16/9;"></iframe> <blockquote> <p>Problema ispirato da <a href="https://plus.maths.org/content/mathematical-dating">https://plus.maths.org/content/mathematical-dating</a>.</p> </blockquote> <h3 id=traffic_problem ><a href="#traffic_problem" class=header-anchor >Traffic problem</a></h3> <p>Si consideri una rete di traffico descritta da un grafo \(G = (V, A)\) i cui archi rappresentano le strade di una città e nodi rappresentano gli incroci. I cittadini si spostano ogni giorno da alcune origini verso alcune destinazioni. Sia \(d_k\) la quantità di auto che lasciano punto \(s_k \in V\) e si spostano verso la destinazione \(t_k \in V\). Sia \(\text{FFT}_{ij}\) &#40;<em>free flow time</em>&#41; il tempo di percorrenza della strada &#40;arco&#41; \((i, j)\) se la strada \((i, j)\) è vuota. Il tempo di viaggio su un arco aumenta però naturalmente con il flusso crescente su quell&#39;arco. Una soglia di congestione \(u_{ij}\) viene quindi definita per ogni arco e non deve essere superata dal traffico lungo quella strada.<br />Modellare il problema di assegnazione del traffico alle strade in modo da ridurre al minimo il tempo totale di viaggio.</p> <p><pre><code class=language-julia >using JuMP
using Ipopt
using Plots
using Random

Random.seed&#33;&#40;42&#41;

# Example data for nodes &#40;V&#41;, arcs &#40;A&#41;, and demands &#40;K&#41;
n_nodes &#61; 5
V &#61; 1:n_nodes  # Nodes
A &#61; &#91;&#40;i, j&#41; for i in 1:n_nodes for j in 1:n_nodes if i &#33;&#61; j&#93;  # Arcs
K &#61; &#91;&#40;1, 4&#41;, &#40;2, 3&#41;, &#40;2, 4&#41;, &#40;2, 5&#41;&#93;  # Origin-destination pairs
d &#61; 100*ones&#40;length&#40;K&#41;&#41;  # Demand for each origin-destination pair

# Free flow travel time for each arc &#40;FFTi&#41; and congestions u_ij
FFTi &#61; Dict&#123;Tuple&#123;Int, Int&#125;, Float64&#125;&#40;&#41;
u &#61; Dict&#123;Tuple&#123;Int, Int&#125;, Float64&#125;&#40;&#41;

for arc in A
    FFTi&#91;arc&#93; &#61; rand&#40;1:10&#41;  # Random travel time between 1 and 10
    u&#91;arc&#93; &#61; rand&#40;80:120&#41;  # Random congestion threshold between 80 and 120
end

# Create the optimization model
model &#61; Model&#40;Ipopt.Optimizer&#41;

# Define variables: x&#91;k,i,j&#93; for each demand pair &#40;k&#41; and arc &#40;i,j&#41;
@variable&#40;model, x&#91;1:length&#40;K&#41;, 1:length&#40;A&#41;&#93; &gt;&#61; 0&#41;

# Objective: Minimize total travel time
@objective&#40;model, Min, sum&#40;FFTi&#91;A&#91;j&#93;&#93; * sum&#40;x&#91;k, j&#93; for k in 1:length&#40;K&#41;&#41; for j in 1:length&#40;A&#41;&#41;&#41;

# Flow conservation constraints
for k in 1:length&#40;K&#41;
    s_k, t_k &#61; K&#91;k&#93;
    for i in V
        if i &#61;&#61; s_k
            @constraint&#40;model, sum&#40;x&#91;k, j&#93; for j in 1:length&#40;A&#41; if A&#91;j&#93;&#91;1&#93; &#61;&#61; i&#41; - sum&#40;x&#91;k, j&#93; for j in 1:length&#40;A&#41; if A&#91;j&#93;&#91;2&#93; &#61;&#61; i&#41; &#61;&#61; d&#91;k&#93;&#41;
        elseif i &#61;&#61; t_k
            @constraint&#40;model, sum&#40;x&#91;k, j&#93; for j in 1:length&#40;A&#41; if A&#91;j&#93;&#91;1&#93; &#61;&#61; i&#41; - sum&#40;x&#91;k, j&#93; for j in 1:length&#40;A&#41; if A&#91;j&#93;&#91;2&#93; &#61;&#61; i&#41; &#61;&#61; -d&#91;k&#93;&#41;
        else
            @constraint&#40;model, sum&#40;x&#91;k, j&#93; for j in 1:length&#40;A&#41; if A&#91;j&#93;&#91;1&#93; &#61;&#61; i&#41; - sum&#40;x&#91;k, j&#93; for j in 1:length&#40;A&#41; if A&#91;j&#93;&#91;2&#93; &#61;&#61; i&#41; &#61;&#61; 0&#41;
        end
    end
end

# Congestion threshold constraints
for j in 1:length&#40;A&#41;
    @constraint&#40;model, sum&#40;x&#91;k, j&#93; for k in 1:length&#40;K&#41;&#41; &lt;&#61; u&#91;A&#91;j&#93;&#93;&#41;
end

# Solve the model
optimize&#33;&#40;model&#41;

# Extract results
x_opt &#61; value.&#40;x&#41;

# Print results
for k in 1:length&#40;K&#41;
    println&#40;&quot;Traffic flow for demand pair &#36;&#40;K&#91;k&#93;&#41;:&quot;&#41;
    for j in 1:length&#40;A&#41;
        println&#40;&quot;Arc &#36;&#40;A&#91;j&#93;&#41;: &#36;&#40;x_opt&#91;k, j&#93;&#41; cars&quot;&#41;
    end
end


# Plot the traffic network with flows
theta &#61; 2 * π * &#40;0:n_nodes-1&#41; / n_nodes
x_plot &#61; 1 * cos.&#40;theta&#41;
y_plot &#61; 1 * sin.&#40;theta&#41;

arc_plot &#61; &#91;&#40;x_plot&#91;i&#93;, x_plot&#91;j&#93;, y_plot&#91;i&#93;, y_plot&#91;j&#93;&#41; for &#40;i, j&#41; in A&#93;

# Generate a list of colors based on the number of demand pairs
colors &#61; &#91;RGB&#40;rand&#40;&#41;, rand&#40;&#41;, rand&#40;&#41;&#41; for _ in 1:length&#40;K&#41;&#93;

# Function to slightly shift points for better visualization
function shift_points&#40;x1, y1, x2, y2, shift_factor&#41;
    dx &#61; x2 - x1
    dy &#61; y2 - y1
    dist &#61; sqrt&#40;dx^2 &#43; dy^2&#41;
    shift_x &#61; -dy / dist * shift_factor
    shift_y &#61; dx / dist * shift_factor
    return &#40;x1 &#43; shift_x, y1 &#43; shift_y, x2 &#43; shift_x, y2 &#43; shift_y&#41;
end

plot&#40;&#41;
for j in 1:length&#40;A&#41;
    x1, x2, y1, y2 &#61; arc_plot&#91;j&#93;
    for k in 1:length&#40;K&#41;
        flow &#61; x_opt&#91;k, j&#93;
        if flow &gt; 0
            sx1, sy1, sx2, sy2 &#61; shift_points&#40;x1, y1, x2, y2, 0.04 * k&#41;
            plot&#33;&#40;&#91;sx1, sx2&#93;, &#91;sy1, sy2&#93;, arrow&#61;:arrow, label&#61;&quot;&quot;,
                color&#61;colors&#91;k&#93;, linewidth&#61;2,# &#43; flow/50,
                alpha&#61;0.6&#41;
            mid_x &#61; &#40;sx1 &#43; sx2&#41; / 2
            mid_y &#61; &#40;sy1 &#43; sy2&#41; / 2
            annotate&#33;&#40;mid_x, mid_y, text&#40;&quot;&#36;&#40;round&#40;Int64,flow&#41;&#41;&quot;, 8, colors&#91;k&#93;&#41;&#41;
        end
    end
end

scatter&#33;&#40;x_plot, y_plot, label&#61;&quot;Nodes&quot;, legend&#61;:outertopleft&#41;
annotate&#33;&#40;x_plot, y_plot, string.&#40;V&#41;&#41;
for k in 1:length&#40;K&#41;
    label &#61; &quot;Path &#36;&#40;K&#91;k&#93;&#91;1&#93;&#41;→&#36;&#40;K&#91;k&#93;&#91;2&#93;&#41;&quot;
    plot&#33;&#40;&#91;&#93;, &#91;&#93;, color&#61;colors&#91;k&#93;, label&#61;label&#41;
end

title&#33;&#40;&quot;Traffic Network with Flows&quot;&#41;</code></pre> <img src="/assets/scripts/output/traffic_problem.svg" alt=""> <pre><code class="plaintext code-output">This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:      160
Number of nonzeros in inequality constraint Jacobian.:       80
Number of nonzeros in Lagrangian Hessian.............:        0

Total number of variables............................:       80
                     variables with only lower bounds:       80
                variables with lower and upper bounds:        0
                     variables with only upper bounds:        0
Total number of equality constraints.................:       20
Total number of inequality constraints...............:       20
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:       20

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  3.9999960e+00 1.00e+02 7.00e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  4.1623134e+00 1.00e+02 7.00e+00  -1.0 5.03e+01    -  4.96e-04 4.96e-04h  1
   2  2.0988917e+02 9.15e+01 9.43e+00  -1.0 1.00e+02    -  2.23e-04 8.43e-02h  1
   3  5.0421487e+02 7.92e+01 6.43e+00  -1.0 9.28e+01    -  3.08e-01 1.34e-01h  1
   4  1.9743373e+03 1.75e+01 7.49e+00  -1.0 7.93e+01    -  1.21e-02 7.79e-01h  1
   5  1.9924851e+03 1.67e+01 7.04e+00  -1.0 2.70e+01    -  6.14e-02 4.59e-02h  1
   6  2.0759046e+03 1.33e+01 7.24e+00  -1.0 2.78e+01    -  2.05e-02 2.03e-01h  1
   7  2.1551123e+03 1.03e+01 7.24e+00  -1.0 3.57e+01    -  4.91e-02 2.30e-01h  1
   8  2.1629523e+03 9.96e+00 2.80e+00  -1.0 3.03e+01    -  5.85e-01 2.97e-02h  1
   9  2.1640031e+03 9.91e+00 3.09e+00  -1.0 9.93e+01    -  2.10e-02 4.79e-03h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  2.2568808e+03 6.01e+00 4.20e+00  -1.0 1.01e+02    -  1.71e-02 3.93e-01h  1
  11  2.3867583e+03 2.02e+00 3.97e+00  -1.0 5.10e+01    -  1.20e-01 6.64e-01h  1
  12  2.4369340e+03 7.93e-01 9.18e-01  -1.0 6.10e+00    -  7.83e-01 6.08e-01h  1
  13  2.4696395e+03 1.21e-09 3.09e-01  -1.0 4.05e+00    -  5.24e-01 1.00e+00h  1
  14  2.4696125e+03 3.22e-10 4.90e-03  -1.0 4.16e+00    -  9.87e-01 1.00e+00f  1
  15  2.4643106e+03 1.12e-10 2.00e-07  -1.7 3.21e-01    -  1.00e+00 1.00e+00f  1
  16  2.4630097e+03 1.03e-11 4.28e-06  -3.8 6.23e-02    -  1.00e+00 1.00e+00f  1
  17  2.4630001e+03 2.84e-14 1.85e-11  -5.7 1.05e-02    -  1.00e+00 1.00e+00f  1
  18  2.4630000e+03 1.42e-14 2.66e-14  -8.6 1.51e-03    -  1.00e+00 1.00e+00f  1

Number of Iterations....: 18

                                   (scaled)                 (unscaled)
Objective...............:   2.4629999790753836e+03    2.4629999790753836e+03
Dual infeasibility......:   2.6645352591003757e-14    2.6645352591003757e-14
Constraint violation....:   1.4210854715202004e-14    1.4210854715202004e-14
Variable bound violation:   9.8526023534162266e-09    9.8526023534162266e-09
Complementarity.........:   3.4143293206596104e-09    3.4143293206596104e-09
Overall NLP error.......:   3.4143293206596104e-09    3.4143293206596104e-09


Number of objective function evaluations             = 19
Number of objective gradient evaluations             = 19
Number of equality constraint evaluations            = 19
Number of inequality constraint evaluations          = 19
Number of equality constraint Jacobian evaluations   = 1
Number of inequality constraint Jacobian evaluations = 1
Number of Lagrangian Hessian evaluations             = 1
Total seconds in IPOPT                               = 0.021

EXIT: Optimal Solution Found.</code></pre></p> <blockquote> <p>Problema tratto dagli esercizi del corso di Optimization al polimi</p> </blockquote> <h3 id=polygon_problem ><a href="#polygon_problem" class=header-anchor >Polygon problem</a></h3> <p>Dato un numero intero positivo \(n\), trovare il poligono con \(n\) lati con diametro &#40;ovvero la distanza massima tra due vertici&#41; minore o uguale a 1, e di area massima.</p> <p>Un suo esempio di applicazione reale sarebbe massimizzare l&#39;area delimitata da un recinto, imponendo che questo possa essere chiuso in sottorecinti a piacere se necessario, usando staccionate unitarie &#40;ovvero la distanza tra ogni coppia di vertice deve essere ≤1&#41;.</p> <p><pre><code class=language-julia >using JuMP
using Ipopt
using Plots

# Define the number of vertices
n &#61; 5 # You can change this to the desired number of vertices

# Create the optimization model
model &#61; Model&#40;Ipopt.Optimizer&#41;

# Define variables: r and phi for each vertex
@variable&#40;model, r&#91;1:n&#93; &gt;&#61; 0&#41;
@variable&#40;model, 0 &lt;&#61; phi&#91;1:n&#93; &lt;&#61; 2π&#41;

# Define the objective function &#40;maximize area&#41;
@objective&#40;model, Max,
    0.5 * sum&#40;r&#91;i&#93; * r&#91;i&#43;1&#93; * sin&#40;phi&#91;i&#43;1&#93; - phi&#91;i&#93;&#41; for i in 1:n-1&#41; &#43;
    0.5 * r&#91;n&#93; * r&#91;1&#93; * sin&#40;2π - phi&#91;n&#93; &#43; phi&#91;1&#93;&#41;
&#41;

# Define the constraints for the distance between each pair of vertices
@constraint&#40;model, &#91;i&#61;1:n, j&#61;1:n; j &gt; i&#93;, r&#91;i&#93;^2 &#43; r&#91;j&#93;^2 - 2 * r&#91;i&#93; * r&#91;j&#93; * cos&#40;phi&#91;i&#93; - phi&#91;j&#93;&#41; &lt;&#61; 1&#41;

# Define the constraints for ordering angles
@constraint&#40;model, &#91;i&#61;1:n-1&#93;, phi&#91;i&#93; &lt;&#61; phi&#91;i&#43;1&#93;&#41;

# Solve the model
optimize&#33;&#40;model&#41;

# Get the optimal values for r and phi
r_opt &#61; value.&#40;r&#41;
phi_opt &#61; value.&#40;phi&#41;

# Convert polar coordinates to Cartesian coordinates for plotting
x &#61; r_opt .* cos.&#40;phi_opt&#41;
y &#61; r_opt .* sin.&#40;phi_opt&#41;

# Add the first vertex to close the polygon
x &#61; vcat&#40;x, x&#91;1&#93;&#41;
y &#61; vcat&#40;y, y&#91;1&#93;&#41;

println&#40;&quot;Case n&#61;&#36;n&quot;&#41;
for i in 1:length&#40;x&#41;
    println&#40;&quot;P_&#36;i &#61; &#40;&quot;,round&#40;x&#91;i&#93;,digits&#61;4&#41;, &quot;, &quot;, round&#40;y&#91;i&#93;,digits&#61;4&#41;,&quot;&#41;&quot;&#41;
end

# Plot the resulting polygon
plot&#40;x, y, seriestype&#61;:shape, label&#61;&quot;Optimal Polygon&quot;, fillalpha&#61;0.3, aspect_ratio&#61;:equal, legend&#61;false&#41;
scatter&#33;&#40;x, y, label&#61;&quot;Vertices&quot;&#41;
title&#33;&#40;&quot;Optimal Polygon with n&#61;&#36;n Vertices&quot;&#41;

# Function to generate points on a circle
function circle_points&#40;center_x, center_y, radius, num_points&#61;100&#41;
    theta &#61; range&#40;0, 2*pi, length&#61;num_points&#41;
    cx &#61; center_x .&#43; radius .* cos.&#40;theta&#41;
    cy &#61; center_y .&#43; radius .* sin.&#40;theta&#41;
    return cx, cy
end
# Plot a circle of radius 1 from each vertex
for i in 1:n
    circle_x, circle_y &#61; circle_points&#40;x&#91;i&#93;, y&#91;i&#93;, 1&#41;
    plot&#33;&#40;circle_x, circle_y, label&#61;false, linestyle&#61;:solid, color&#61;:red, alpha&#61;0.3&#41;
end

xlims&#33;&#40;minimum&#40;x&#41;-0.2, maximum&#40;x&#41;&#43;0.2&#41;
ylims&#33;&#40;minimum&#40;y&#41;-0.2, maximum&#40;y&#41;&#43;0.2&#41;</code></pre> </p> <img src="/assets/scripts/output/polygon_10.svg" alt=""> <blockquote> <p>Problema tratto dagli esercizi del corso di Optimization al polimi</p> </blockquote> <h3 id=modi_per_salire_una_scala ><a href="#modi_per_salire_una_scala" class=header-anchor >Modi per salire una scala</a></h3> <p></p> <iframe width="80%" style="aspect-ratio:16/9; margin: auto;" src="https://www.youtube.com/embed/HWJOsKOcUJk?rel=0"> </iframe> <p></p> <p>In quanti modi si può salire una scala lunga \(n\) gradini, potendo salire al massimo 2 scalini per volta? Chiamando \(S(n)\) questo numero di modi in funzione di \(n\), risulta che la soluzione è data da</p> \[ S(n) = S(n-1) + S(n-2) \] <p>perché moralmente come primo passo dobbiamo sempre fare un passo lungo 1 o lungo 2, indipendentemente da quanto la scala sia alta, e da quei passi poi possiamo osservare di fronte a noi una scala alta \(n-1\) ed \(n-2\) scalini, rispettivamente, e quindi riciclare i calcoli già fatti prima per le altre scale.</p> <p>Mentre generalizzando il calcolo, supponendo cioè di avere un altro parametro \(k\) che regola quanti scalini risuciamo a salire al massimo con un solo passo, la soluzione diventa</p> \[ S(n) = S(n-1) + S(n-2) + \ldots + S(n-k) \] <p>dove però ora i vari valori \(S(n-i)\) si devono trovare in modi a volte meno ovvi. Per capire tutto, insieme ad una semplice idea per convertire il calcolo in codice eseguibile da un computer vi rimando naturalmente al video.</p> <p><pre><code class=language-julia >using Plots

function S&#40;n,k&#41;
	n&#61;&#61;0 &amp;&amp; return 0
	n&#61;&#61;1 &amp;&amp; return 1
	if n&lt;k 
		return S&#40;n,n&#41;
	elseif n&#61;&#61;k
		return S&#40;n,k-1&#41;&#43;1
	else # n&gt;k
		return sum&#40;S&#40;n-i,k&#41; for i in 1:k&#41;
	end
end

scale &#61; 1:14
modi_1 &#61; S.&#40;scale,1&#41;
modi_2 &#61; S.&#40;scale,2&#41;
modi_3 &#61; S.&#40;scale,3&#41;
modi_4 &#61; S.&#40;scale,4&#41;
modi_5 &#61; S.&#40;scale,5&#41;

plot&#40;scale, modi_1, marker&#61;:circle, line&#61;:solid, label&#61;&quot;k&#61;1&quot;, legend&#61;:left&#41;
plot&#33;&#40;scale, modi_2, marker&#61;:circle, line&#61;:solid, label&#61;&quot;k&#61;2&quot;&#41;
plot&#33;&#40;scale, modi_3, marker&#61;:circle, line&#61;:solid, label&#61;&quot;k&#61;3&quot;&#41;
plot&#33;&#40;scale, modi_4, marker&#61;:circle, line&#61;:solid, label&#61;&quot;k&#61;4&quot;&#41;
plot&#33;&#40;scale, modi_5, marker&#61;:circle, line&#61;:solid, label&#61;&quot;k&#61;5&quot;&#41;

plot&#33;&#40;xticks&#61;collect&#40;scale&#41;&#41;
xlabel&#33;&#40;&quot;Gradini&quot;&#41;
ylabel&#33;&#40;&quot;Modi&quot;&#41;
title&#33;&#40;&quot;Comparison of S&#40;n, k&#41; for different k values&quot;&#41;</code></pre> <div id=fdpgtj  style=""></div> <script> graphDiv = document.getElementById("fdpgtj"); plotlyPromise = PlotlyJS_json(graphDiv, '/assets/scripts/output/scale.json'); </script> </p> <label for=inputN >n:</label> <input type=number  id=inputN  min=1 > <label for=inputK >k:</label> <input type=number  id=inputK  min=1 > <button onclick="calculate()">Calcola</button> <div id=result ></div> <script> function S(n, k) { let dp = Array.from({ length: n + 1 }, () => Array(k + 1).fill(0)); for (let j = 1; j <= k; j++) { dp[1][j] = 1; } for (let i = 2; i <= n; i++) { for (let j = 1; j <= k; j++) { if (i < j) { dp[i][j] = dp[i][i]; } else if (i == j) { dp[i][j] = dp[i][j - 1] + 1; } else { dp[i][j] = 0; for (let m = 1; m <= j; m++) { dp[i][j] += dp[i - m][j]; } } } } return dp[n][k]; } function calculate() { let n = parseInt(document.getElementById("inputN").value); let k = parseInt(document.getElementById("inputK").value); let result = S(n, k); document.getElementById("result").innerText = `Risultato: ${result}`; } </script> <blockquote> <p>Problema ispirato da <a href="https://plus.maths.org/content/its-long-way-top">https://plus.maths.org/content/its-long-way-top</a>.</p> </blockquote> <h3 id=condivisione_equa_di_diversi_contributi ><a href="#condivisione_equa_di_diversi_contributi" class=header-anchor >Condivisione equa di diversi contributi</a></h3> <p>Due amiche, Astrid e Beatrice, hanno organizzato un picnic. Per pigrizia hanno però deciso di cucinare un&#39;unica pietanza, il riso freddo, e si sono anche accordate che ognuna preparasse quante porzioni riuscisse e che poi le avrebbero condivise ed eventualmente sistemato i conti alla fine. </p> <p>Astrid ha portato con sé 3 porzioni di riso freddo, mentre Beatrice 5. Sono sul punto di pranzare quando&#39;ecco che appare anche Chiara&#33;, un&#39;altra loro amica, che chiede di unirsi a loro per il picnic, pur non avendo portato niente, ma ovviamente promettendo di saldare il conto alla fine. Astrid e Beatrice accolgono quindi volentieri la nuova arrivata. A questo punto, dividono ogni porzione in tre parti uguali &#40;dove supponiamo che ogni parte valga 1€<sup id="fnref:3"><a href="#fndef:3" class=fnref >[3]</a></sup>&#41;, generando quindi 9 porzioncine dalle tre porzioni originali di Astrid e 15 dalle cinque di Beatrice, e se le distribuiscono tra loro. Le tre amiche sono molto affamate, e quindi ognuna finisce interamente il riso che le è stato assegnato.</p> <p>&quot;Gran bella mangiata&#33;&quot; riassume alla fine Chiara, &quot;ma... quanto vi devo? Vediamo: io ho mangiato 8 porzioncine, dalle vostre 3&#43;5 porzioni originali, per quindi un costo di 8€. Di tutto il riso, tu Astrid ne avevi portato i 3/8, mentre Beatrice 5/8, quindi... dovrei dare 3€ ad Astrid e 5€ a Bea, giusto?&quot;. &quot;Mi sembra giusto&quot; conferma Astrid. &quot;No invece&#33;&quot; esclama Beatrice, scioccata dall&#39;incompetenza matematica delle sue amiche.</p> <p>In effetti Beatrice ha ragione. <em>Ma perché? E quale sarebbe la divisione più corretta?</em> </p> <p>Il problema può essere esteso in forma generale avendo un picnic con \(k\) amiche iniziali, in cui ognuna porta \(n_1, \ldots, n_k\) porzioni di riso, che sono poi raggiunte da altre \(m\) amiche che non hanno portato nulla, ma che alla fine devono pagare una certa somma alle altre amiche.</p> <blockquote> <p>Problema ispirato da <a href="https://plus.maths.org/content/sharing-cakes">https://plus.maths.org/content/sharing-cakes</a>.</p> </blockquote> <table class=fndef  id="fndef:3"> <tr> <td class=fndef-backref ><a href="#fnref:3">[3]</a> <td class=fndef-content >questa è solo una semplificazione. Si potrebbe fissare, in modo più verosimile, il costo della porzione inziale &#40;intera&#41;, e non della sotto-porzione &#40;divisa&#41;, ma questo complicherebbe solo i calcoli. Comunque una volta trovata la soluzione si può convertirla in valori &quot;relativi&quot; e quindi si può ripristinare il valore esatto in base al costo vero della porzione di partenza. </table> <h3 id=triello_probabilistico ><a href="#triello_probabilistico" class=header-anchor >Triello probabilistico</a></h3> <p>Tre signori A, B e C hanno fissato un duello a tre armi – un triello quindi – per risolvere una disputa. Erano amici da molto tempo, solo quest&#39;ultima lite ha irrimediabilmente rotto ogni rapporto, quindi tutti conoscono le caratteristiche di tutti: si sa che l&#39;accuratezza, ovvero la probabilità di colpire il bersaglio, di A è 0.3, di C è 0.5, mentre B è infallibile, lo centra sempre.</p> <p>È stato fissato l&#39;ordine di inizio: A, B, poi C. Ognuno, al proprio turno, deve sparare un colpo decidendo come vuole il suo bersaglio, valutando per esempio quale sia la sua strategia ottimale per sopravvivere. Ovviamente, uno viene ucciso se colpito, e quindi non può eseguire il proprio turno di sparo. Il triello finisce quando un solo uomo rimane vivo.</p> <p><em>Se voi foste il signor A, quale strategia utilizzereste?</em></p> <img src="/assets/img/duello_cut.png" alt=""> <h3 id=testando_la_resistenza_delle_uova ><a href="#testando_la_resistenza_delle_uova" class=header-anchor >Testando la resistenza delle uova</a></h3> <p>Immaginate di essere un allevatore che, incrociando varie razze di gallina, è riuscito ad ottenerne una che depone delle uova particolarmente forti. Volete quindi testare di preciso quanto siano resistenti queste uova, e per farlo decidete di lanciarle dai vari piani di un edificio di 100 piani con l&#39;obiettivo di trovare il piano più alto da cui un uovo può cadere senza rompersi.</p> <p>Se aveste un solo uovo sapreste subito come fare: prima lanciate l&#39;uovo dal primo piano, se non si rompe passate al secondo, poi al terzo, e così via. Ci vorrebbero, nel caso peggiore, 100 lanci per trovare la soluzione. </p> <p>Ma ora supponiamo che voi abbiate 2 uova. <em>Quale strategia utilizzereste ora per trovare la risposta in modo da minimizzare il caso peggiore del numero di lanci da effettuare?</em></p> <p>Supponete infine di avere \(k\) uova. <em>Quale strategia utilizzereste, in questo caso &#40;sempre per minimizzare il caso peggiore del numero di lanci da effettuare&#41;?</em></p> <img src="/assets/img/gallina2_cut.png" alt=""> <blockquote> <p>Problema ispirato da <a href="https://plus.maths.org/content/dropping-eggs">https://plus.maths.org/content/dropping-eggs</a>.</p> </blockquote> <p>La funzione che segue &#40;che è stata complicatuccia da scrivere&#41; simula l&#39;esecuzione del lancio di \(k\) uova, usando un <em>jump&#95;size</em> diverso in funzione del numero di uova rimaste. Per esempio, <code>strat_vector &#61; &#91;14,1&#93;</code> corrisponde al caso in cui abbiamo 2 uova, e finché ne abbiamo due saltiamo di 14, poi 13, poi 12 piani, mentre quando ci rimane un solo uovo allora facciamo passi alti sempre 1. Mentre <code>strat_vector &#61; &#91;18,7,1&#93;</code> corrisponde alla simulazione in cui abbiamo 3 uova, e se ne finché ne abbiamo tre effettuiamo salti alti 18, poi 17, 16, ecc; quando ne abbbiamo due salti alti 7, poi 6, 5, ecc; e infine quando ne abbbiamo solo uno salti alti 1.</p> <pre><code class=language-julia >function the_egg_breaks&#40;testing_floor, critical_floor&#41;
    return testing_floor&gt;critical_floor
end

function print_summary&#40;eggs::Integer, floor::Integer, steps::Integer, jump_size::Integer, solution&#41;
    println&#40;&quot;jump size &#61; &#36;&#40;rpad&#40;jump_size,2&#41;&#41;, &quot;,
            &quot;🏯&#61;&#36;&#40;rpad&#40;string&#40;floor&#41;,3&#41;&#41;, &quot;,
            &quot;🥚&#61;&#36;&#40;rpad&#40;string&#40;eggs&#41;,2&#41;&#41;, &quot;,
            &quot;🪜&#61;&#36;&#40;rpad&#40;string&#40;steps&#41;,2&#41;&#41;&quot;&#41;
end

function foundable&#40;solution::Vector, verbose&#61;false&#41;
    if verbose println&#40;join&#40;map&#40;string, solution&#41;&#41;&#41;; end
    # 2 was the default value
    # 1 is for floors where the egg breaks
    # 0 is for floors where the egg does not break
    return occursin&#40;&quot;01&quot;,join&#40;map&#40;string, solution&#41;&#41;&#41; || 
           join&#40;map&#40;string, solution&#41;&#41; &#61;&#61; repeat&#40;&#39;0&#39;,100&#41;
end

function stratk&#40;divs_strat::Vector, critical_floor::Integer, verbose::Bool&#41;
    solution &#61; 2 .* ones&#40;Int,100&#41;
    eggs &#61; length&#40;divs_strat&#41;
    steps &#61; 0
    strats &#61; reverse&#40;copy&#40;divs_strat&#41;&#41;
    previous_floor &#61; 0
    current_floor &#61; strats&#91;end&#93;
    jump_size &#61; strats&#91;eggs&#93;

    while &#33;foundable&#40;solution,verbose&#41; &amp;&amp; steps&lt;&#61;100
        interval_focus &#61; findlast&#40;x-&gt;x&#61;&#61;&#39;2&#39;,join&#40;map&#40;string, solution&#41;&#41;&#41; - 
                         findfirst&#40;x-&gt;x&#61;&#61;&#39;2&#39;,join&#40;map&#40;string, solution&#41;&#41;&#41; &#43; 1
        eggs&lt;1 &amp;&amp; return NaN
        jump_size&lt;1 &amp;&amp; return NaN
        current_floor&lt;1 &amp;&amp; return NaN

        if isnothing&#40;findlast&#40;x-&gt;x&#61;&#61;&#39;1&#39;,join&#40;map&#40;string,solution&#41;&#41;&#41;&#41;
            max_index &#61; 100
        else
            max_index &#61; findlast&#40;x-&gt;x&#61;&#61;&#39;1&#39;,join&#40;map&#40;string,solution&#41;&#41;&#41;-1
        end
        current_floor&#61;min&#40;current_floor,max_index&#41;
    
        if the_egg_breaks&#40;current_floor, critical_floor&#41;
            eggs -&#61; 1
            steps &#43;&#61; 1
            solution&#91;current_floor:end&#93; .&#61; 1
            if verbose print_summary&#40;eggs,current_floor,steps,jump_size,solution&#41;; end
            current_floor &#61; previous_floor &#43;1
            jump_size &#61; eggs&gt;&#61;1 ? strats&#91;eggs&#93; : 1
        else
            solution&#91;1:current_floor&#93; .&#61; 0
            steps &#43;&#61; 1
            if verbose print_summary&#40;eggs,current_floor,steps,jump_size,solution&#41;; end
            if eggs&gt;1 jump_size -&#61; 1 end
            previous_floor &#61; current_floor
            current_floor &#43;&#61; jump_size
        end
    end
    return steps
end</code></pre> <pre><code class=language-julia >julia&gt; stratk&#40;&#91;14,1&#93;,58,true&#41;
jump size &#61; 14, 🏯&#61;14 , 🥚&#61;2 , 🪜&#61;1
jump size &#61; 13, 🏯&#61;27 , 🥚&#61;2 , 🪜&#61;2
jump size &#61; 12, 🏯&#61;39 , 🥚&#61;2 , 🪜&#61;3
jump size &#61; 11, 🏯&#61;50 , 🥚&#61;2 , 🪜&#61;4
jump size &#61; 10, 🏯&#61;60 , 🥚&#61;1 , 🪜&#61;5
jump size &#61; 1 , 🏯&#61;51 , 🥚&#61;1 , 🪜&#61;6
jump size &#61; 1 , 🏯&#61;52 , 🥚&#61;1 , 🪜&#61;7
jump size &#61; 1 , 🏯&#61;53 , 🥚&#61;1 , 🪜&#61;8
jump size &#61; 1 , 🏯&#61;54 , 🥚&#61;1 , 🪜&#61;9
jump size &#61; 1 , 🏯&#61;55 , 🥚&#61;1 , 🪜&#61;10
jump size &#61; 1 , 🏯&#61;56 , 🥚&#61;1 , 🪜&#61;11
jump size &#61; 1 , 🏯&#61;57 , 🥚&#61;1 , 🪜&#61;12
jump size &#61; 1 , 🏯&#61;58 , 🥚&#61;1 , 🪜&#61;13
jump size &#61; 1 , 🏯&#61;59 , 🥚&#61;0 , 🪜&#61;14
14

julia&gt; stratk&#40;&#91;18,7,1&#93;,58,true&#41;
jump size &#61; 18, 🏯&#61;18 , 🥚&#61;3 , 🪜&#61;1
jump size &#61; 17, 🏯&#61;35 , 🥚&#61;3 , 🪜&#61;2
jump size &#61; 16, 🏯&#61;51 , 🥚&#61;3 , 🪜&#61;3
jump size &#61; 15, 🏯&#61;66 , 🥚&#61;2 , 🪜&#61;4
jump size &#61; 7 , 🏯&#61;52 , 🥚&#61;2 , 🪜&#61;5
jump size &#61; 6 , 🏯&#61;58 , 🥚&#61;2 , 🪜&#61;6
jump size &#61; 5 , 🏯&#61;63 , 🥚&#61;1 , 🪜&#61;7
jump size &#61; 1 , 🏯&#61;59 , 🥚&#61;0 , 🪜&#61;8
8</code></pre> <div id=fdpqcc  style=""></div> <script> graphDiv = document.getElementById("fdpqcc"); plotlyPromise = PlotlyJS_json(graphDiv, '/assets/scripts/output/dropping_eggs_all.json'); </script> <h3 id=babbo_natale_e_le_dismutazioni ><a href="#babbo_natale_e_le_dismutazioni" class=header-anchor >Babbo Natale e le dismutazioni</a></h3> <p>Babbo Natale ha ricevuto \(n\) letterine dai bambini di tutto il mondo, ciascuna con la lista di regali desiderati. Dopo aver letto attentamente tutte le letterine, e organizzato le spedizioni dei regali, Babbo Natale decide di rispondere personalmente a ciascun bambino, scrivendo un&#39;altra lettera come risposta.</p> <p>Tuttavia, nella fretta di preparare tutto per le feste, Babbo Natale e i suoi elfi responsabili della logistica si confondono e così, quando sono sul punto di spedire tutto, finiscono per mettere le lettere di risposta nelle varie buste in modo completamente casuale.</p> <p><em>Qual è la probabilità che nessun bambino riceva la lettera di risposta che era destinata a lui?</em></p> <img src="/assets/img/bnatale1_cut.jpg" alt=""> <div class=page-foot > Last modified: August 01, 2025. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the lovely <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> <script src="/libs/katex/katex.min.js"></script> <script src="/libs/katex/contrib/auto-render.min.js"></script> <script>renderMathInElement(document.body)</script> <!-- <script> MathJax = { tex: { inlineMath: [['\\(', '\\)']], tags: 'all' }, svg: {fontCache: 'global'} }; </script> <script id=MathJax-script  async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script> --> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>