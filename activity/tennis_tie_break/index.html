<!doctype html> <html lang=en > <a id=top ></a> <link rel=icon  href="/assets/favicon.png"> <link rel=icon  type="image/x-icon" href="/assets/favicon.png"> <link rel=icon  type="image/png" href="/assets/favicon.png"/> <link rel=icon  href="/assets/main img.jpg"> <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { response = await fetch(url); fig = await response.json(); Plotly.newPlot(div, fig); }; </script> <link rel=stylesheet  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_hyde.css"> <link rel=icon  href="/assets/favicon.png"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <title>Tennis tie-break probability</title> <!-- <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { console.log("url: ",url); console.log("div: ",div); response = await fetch(url); fig = await response.json(); if (typeof fig.config === 'undefined') { fig["config"]={} } delete fig.layout.width delete fig.layout.height fig["layout"]["autosize"] = true fig["config"]["autosizable"] = true fig["config"]["responsive"] = true fig.config["scrollZoom"] = false delete fig.config.staticPlot delete fig.config.displayModeBar delete fig.config.doubleClick delete fig.config.showTips Plotly.newPlot(div, fig); }; </script> --> <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { response = await fetch(url); fig = await response.json(); Plotly.newPlot(div, fig); }; </script> <!-- <a class=backToTopBtn  title="back to top // torna in cima" href="#top"> <span class=backToTopBtn-icon >^</span> </a> --> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <!-- <h1><a href="/">Hyde</a></h1> <p class=lead >A two-column theme.</p> --> <h1><a href="/">Eccoci.<img style="display: block; margin: 0 auto; margin-bottom: 20px"; width=170 ; src="/assets/main img.jpg" alt="main img"/></a></h1> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/">Home</a> <a class="sidebar-nav-item " href="/activity/">Attività</a> <a class="sidebar-nav-item " href="/uni/">Uni</a> <a class="sidebar-nav-item " href="/portfolio/">Portfolio</a> </nav> <a href="https://www.youtube.com/channel/UC1_68R2Kv1htcZ1It5il7CQ" target=_blank rel=noopener> <i class="fab fa-youtube big-icon"></i></a> <a href="https://www.instagram.com/divergentissimo/" target=_blank rel=noopener> <i class="fab fa-instagram big-icon"></i></a> <a href="https://www.linkedin.com/in/federico-angelo-mor/" target=_blank rel=noopener> <i class="fab fa-linkedin big-icon"></i></a> <a href="https://github.com/federicomor" target=_blank rel=noopener> <i class="fab fa-github big-icon"></i></a> </div> </div> <div class="content container"> <a class=backToTopBtn  title="back to top // torna in cima" href="#top"> <span class=backToTopBtn-icon >∧</span> </a> <div class=franklin-content > <h2 id=tennis_tie-break_probability ><a href="#tennis_tie-break_probability" class=header-anchor >Tennis tie-break probability</a></h2> <p>Siamo in una partita di tennis, i due giocatori A e B sono arrivati 6-6 e ora tutto si deciderà al tie-break. Durante la partita, da bravi &#40;ingegneri&#41; matematici, siamo riusciti a stimare due parametri \(a\) e \(b\) che descrivono le probabilità, per il giocatore A, di vincere un punto quando lui è al servizio o quando B è al servizio, rispettivamente. Ma eccoci, il giocatore A si sta apprestando ad iniziare il tie-break&#33; sarà lui infatti a iniziare a servire per primo. Dato questo contesto e questi dati, qual è la probabilità che il giocatore A vinca il tie-break?</p> <p></p> <iframe width="80%" style="aspect-ratio:16/9; margin: auto;" src="https://www.youtube.com/embed/ra9LTkehYk4?rel=0"> </iframe> <p></p> <h2 id=soluzione ><a href="#soluzione" class=header-anchor >Soluzione</a></h2> <p>Da raccontare a parole è molto lunga, quindi vi suggerisco caldamente il video molto dettagliato. L&#39;idea è comunque intanto di decomporre l&#39;evento vittoria nei possibili casi in cui può manifestarsi, ovvero</p> <a id=vincere  class=anchor ></a>\[ \begin{align*} \mathbb P(\text{vincere}) &= \mathbb P(\text{vincere 7-0}) + \mathbb P(\text{vincere 7-1}) + \ldots + \mathbb P(\text{vincere 7-5}) +\\ & + \mathbb P(\text{vincere 8-6}) + \mathbb P(\text{vincere 9-7}) + \ldots\\ \mathbb P(\text{vincere}) &= \mathbb P(\text{vincere 7-0}) + \mathbb P(\text{vincere 7-1}) + \ldots + \mathbb P(\text{vincere 7-5}) + \\ &+\mathbb P(\text{arrivare 6-6})\mathbb P(\text{vincere da 6-6}) \end{align*} \] <p>e poi di studiare ogni termine lavorando con la distribuzione Binomiale. Infatti, una variabile aleatoria \(X\) ha legge Binomiale di parametri \(n\) e \(p\) &#40;e scriviamo \(X\sim\text{Bin}(n,p)\)&#41; quando \(X\) conta il numero di successi che otteniamo quando replichiamo per \(n\) volte un esperimento che può avere esito di successo con probabilità pari a \(p\). Quindi l&#39;idea è di trattare \(n\) come il numero di volte in cui un giocatore è al servizio o in risposta, mentre \(p\) come la probabilità dell&#39;evento di &quot;successo&quot;, ovvero vincere il punto, ovvero i parametri \(a\) o \(b\). </p> <p>Per esempio, per vincere 7-0, il giocatore A deve vincere tutti i punti, dei quali 3 sono quando lui è al servizio mentre 4 di quando B è al servizio. Usando quindi la legge binomiale, che ha densità di probabilità \(p_X(k) = \mathbb P(X=k) = \tbinom{n}{k}p^k(1-p)^{n-k}\), insieme all&#39;indipendenza degli eventi di vincere un punto, si ricava che</p> \[ \begin{align*} \mathbb P(\text{vincere 7-0}) &= \mathbb P(\text{vincere 3 punti su 3 di quando A è al servizio}) \cdot \\ & \mathbb P(\text{vincere 4 punti su 4 di quando B è al servizio}) \\ &= \binom{3}{3}a^3 \binom{4}{4}b^4 = a^3 b^4 \end{align*} \] <p>Ovviamente questo era il caso facile. Gli altri sono un po&#39; più complicati &#40;c&#39;è da separare il fatto di arrivare a 6 e poi fare l&#39;ultimo punto vincente, e c&#39;è da capire in quanti modi possono distribuirsi i punti per poter vincere con un certo punteggio&#41; ma seguono la stessa logica.</p> <p>L&#39;ultimo termine di <span class=eqref >(<a href="#vincere">1</a>)</span>, quello riguardo alla vittoria nei casi ad oltranza, segue invece un calcolo interessante che comporta una ricorsione. Infatti, dal pareggio &#40;tipo 6-6&#41; possiamo vincere o vincendo i due punti successivi &#40;arrivando 8-6&#41; o vincendone uno e perdendone uno, tornando ad un nuovo pareggio &#40;7-7&#41;, e vincere partendo da questo nuovo pareggio. In questo modo, usando l&#39;indipendenza dei secondi eventi, abbiamo che</p> \[ \begin{align*} \mathbb P(\text{vincere dal pareggio}) &= \mathbb P(\text{vincere i due punti successivi}) +\\ & \mathbb P(\text{tornare al pareggio})\mathbb P(\text{vincere dal pareggio}) \end{align*} \] <p>da cui possiamo quindi ricavare \(\mathbb P(\text{vincere dal pareggio})\). Assemblando tutti i pezzi si arriva alla formulazione che ora segue nel codice e relativi grafici, che descrivono la probabilità di vittoria per il giocatore A, indicata come valori sull&#39;asse \(z\), in funzione dei parametri \(a\) e \(b\) posti sugli assi \(x\) e \(y\), e le sue curve di livello.</p> <p><pre><code class=language-julia >using Plots
using Distributions 

# 1  2  3  4  5  6  7  8  9  10 11 12
# A  B  B  A  A  B  B  A  A  B  B  A
function ptiebreak&#40;a::Real,b::Real&#41;
    p70 &#61; &#40;pdf&#40;Binomial&#40;3,a&#41;,3&#41; * pdf&#40;Binomial&#40;3,b&#41;,3&#41;&#41;*b 
    # batte B al 7mo turno
    p71 &#61; sum&#40;&#91;pdf&#40;Binomial&#40;3,a&#41;,i&#41; * pdf&#40;Binomial&#40;4,b&#41;,6-i&#41; for i in 2:3&#93;&#41;*a 
    # batte A all&#39;8vo turno
    p72 &#61; sum&#40;&#91;pdf&#40;Binomial&#40;4,a&#41;,i&#41; * pdf&#40;Binomial&#40;4,b&#41;,6-i&#41; for i in 2:4&#93;&#41;*a 
    # batte A al 9no turno
    p73 &#61; sum&#40;&#91;pdf&#40;Binomial&#40;5,a&#41;,i&#41; * pdf&#40;Binomial&#40;4,b&#41;,6-i&#41; for i in 2:5&#93;&#41;*b 
    # batte B al 10mo turno 
    p74 &#61; sum&#40;&#91;pdf&#40;Binomial&#40;5,a&#41;,i&#41; * pdf&#40;Binomial&#40;5,b&#41;,6-i&#41; for i in 1:5&#93;&#41;*b 
    # batte B al 11mo turno
    p75 &#61; sum&#40;&#91;pdf&#40;Binomial&#40;5,a&#41;,i&#41; * pdf&#40;Binomial&#40;6,b&#41;,6-i&#41; for i in 0:5&#93;&#41;*a
    # batte A al 12mo turno
    p66 &#61; sum&#40;&#91;pdf&#40;Binomial&#40;6,a&#41;,i&#41; * pdf&#40;Binomial&#40;6,b&#41;,6-i&#41; for i in 0:6&#93;&#41;
    pda66 &#61; a*b/&#40;1-a-b&#43;2*a*b&#41; 
    
    ptot &#61; p70&#43;p71&#43;p72&#43;p73&#43;p74&#43;p75&#43;p66*pda66
    @assert 0&lt;&#61;ptot&lt;&#61;1
    return ptot
end

aa &#61; range&#40;0.01,0.99, step&#61;0.01&#41;
bb &#61; range&#40;0.01,0.99, step&#61;0.01&#41;
p &#61; surface&#40;aa, bb, ptiebreak,camera&#61;&#40;25,20&#41;&#41;
xlabel&#33;&#40;&quot;a values&quot;&#41;
ylabel&#33;&#40;&quot;b values&quot;&#41;

contourf&#40;aa, bb, ptiebreak&#41;
xlabel&#33;&#40;&quot;a values&quot;&#41;
ylabel&#33;&#40;&quot;b values&quot;&#41;</code></pre> </p> <div id=fdpwgn  style=""></div> <script> graphDiv = document.getElementById("fdpwgn"); plotlyPromise = PlotlyJS_json(graphDiv, '/assets/scripts/output/tennis_surface.json'); </script> <div id=fdphol  style=""></div> <script> graphDiv = document.getElementById("fdphol"); plotlyPromise = PlotlyJS_json(graphDiv, '/assets/scripts/output/tennis_contourf.json'); </script> <p><br /> Notiamo anche come le apparentemente strane regole del tie-break, in cui il primo giocatore effettua solo un servizio e da lì in poi ci si alterna due servizi a testa &#40;quindi la sequenza di battute sarebbe A|BB|AA|BB|AA|...&#41; hanno in realtà ha perfettamente senso. Infatti, il tie-break in questo modo è <em>equo</em>: chiunque cominci al servizio non ha alcun vantaggio a priori. Questo lo si vede anche dalla matematica &#40;naturalmente 😉&#41;, in cui leggendo il calcolo sempre nella prospettiva di A, ma nel caso in cui fosse B il primo a servire &#40;possiamo modellare questo scenario invertendo i parametri \(a\) e \(b\)&#41;, otterremo comunque le stesse probabilità di vittoria.</p> <p>Usando i numeri decimali classici &#40;i Float64&#41; sembra che escano valori leggermente diversi; ma in realtà sono solo dovuti ad approssimazioni numeriche: passando ad una rappresentazione più precisa &#40;i BigFloat&#41; tutto dovrebbe tornare.</p> <pre><code class=language-julia-repl >julia&gt; ptiebreak&#40;0.60,0.70&#41;
0.8881752145777776

julia&gt; ptiebreak&#40;0.70,0.60&#41;
0.8881752145777777

julia&gt; 1-ptiebreak&#40;0.4,0.3&#41; # altro controllo, cambiando prospettiva su B
0.8881752145777779

julia&gt; ptiebreak&#40;BigFloat&#40;0.60&#41;,BigFloat&#40;0.70&#41;&#41;
0.8881752145777777236370136878239485198844074151971728203443474502251501326155067

julia&gt; ptiebreak&#40;BigFloat&#40;0.70&#41;,BigFloat&#40;0.60&#41;&#41;
0.8881752145777777236370136878239485198844074151971728203443474502251501326155067</code></pre> <p>Piccola digressione. A questo punto magari vi chiederete: ma perché allora in informatica non si usano sempre i BigFloat o comunque queste rappresentazioni più precise? La risposta è perché ok, sono più precise, ma sono anche molto molto più dispensiose in termini di memoria e tempo di esecuzione,</p> <pre><code class=language-julia-repl >julia&gt; @time ptiebreak&#40;BigFloat&#40;0.60&#41;,BigFloat&#40;0.70&#41;&#41;
  0.012136 seconds &#40;15.61 k allocations: 573.875 KiB&#41;
0.8881752145777777236370136878239485198844074151971728203443474502251501326155067

julia&gt; @time ptiebreak&#40;0.60,0.70&#41;
  0.000018 seconds &#40;6 allocations: 576 bytes&#41;
0.8881752145777776</code></pre> <p>e anche perché la precisione base è in genere sufficiente. Non sono infatti molti gli scenari in cui i calcoli effettuati da un computer devono avere un così alto livello di precisione.</p> <script src="https://giscus.app/client.js" data-repo="federicomor/federicomor.github.io" data-repo-id=R_kgDOLBdBYA  data-category=Announcements  data-category-id=DIC_kwDOLBdBYM4Clm0M  data-mapping=url  data-strict=0  data-reactions-enabled=1  data-emit-metadata=0  data-input-position=bottom  data-theme=preferred_color_scheme  data-lang=it  // data-loading=lazy  crossorigin=anonymous  async> </script> <div class=page-foot > Last modified: May 27, 2025. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the lovely <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> <script src="/libs/katex/katex.min.js"></script> <script src="/libs/katex/contrib/auto-render.min.js"></script> <script>renderMathInElement(document.body)</script> <!-- <script> MathJax = { tex: { inlineMath: [['\\(', '\\)']], tags: 'all' }, svg: {fontCache: 'global'} }; </script> <script id=MathJax-script  async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script> --> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>