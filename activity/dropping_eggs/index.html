<!doctype html> <html lang=en > <a id=top ></a> <link rel=icon  href="/assets/favicon.png"> <link rel=icon  type="image/x-icon" href="/assets/favicon.png"> <link rel=icon  type="image/png" href="/assets/favicon.png"/> <link rel=icon  href="/assets/main img.jpg"> <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { response = await fetch(url); fig = await response.json(); Plotly.newPlot(div, fig); }; </script> <link rel=stylesheet  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_hyde.css"> <link rel=icon  href="/assets/favicon.png"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <title>Testando la resistenza delle uova</title> <!-- <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { console.log("url: ",url); console.log("div: ",div); response = await fetch(url); fig = await response.json(); if (typeof fig.config === 'undefined') { fig["config"]={} } delete fig.layout.width delete fig.layout.height fig["layout"]["autosize"] = true fig["config"]["autosizable"] = true fig["config"]["responsive"] = true fig.config["scrollZoom"] = false delete fig.config.staticPlot delete fig.config.displayModeBar delete fig.config.doubleClick delete fig.config.showTips Plotly.newPlot(div, fig); }; </script> --> <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { response = await fetch(url); fig = await response.json(); Plotly.newPlot(div, fig); }; </script> <!-- <a class=backToTopBtn  title="back to top // torna in cima" href="#top"> <span class=backToTopBtn-icon >^</span> </a> --> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <!-- <h1><a href="/">Hyde</a></h1> <p class=lead >A two-column theme.</p> --> <h1><a href="/">Eccoci.<img style="display: block; margin: 0 auto; margin-bottom: 20px"; width=170 ; src="/assets/main img.jpg" alt="main img"/></a></h1> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/">Home</a> <a class="sidebar-nav-item " href="/activity/">Attività</a> <a class="sidebar-nav-item " href="/uni/">Uni</a> <a class="sidebar-nav-item " href="/portfolio/">Portfolio</a> </nav> <a href="https://www.youtube.com/channel/UC1_68R2Kv1htcZ1It5il7CQ" target=_blank rel=noopener> <i class="fab fa-youtube big-icon"></i></a> <a href="https://www.linkedin.com/in/federico-angelo-mor/" target=_blank rel=noopener> <i class="fab fa-linkedin big-icon"></i></a> <a href="https://github.com/federicomor" target=_blank rel=noopener> <i class="fab fa-github big-icon"></i></a> </div> </div> <div class="content container"> <a class=backToTopBtn  title="back to top // torna in cima" href="#top"> <span class=backToTopBtn-icon >∧</span> </a> <div class=franklin-content > <h2 id=testando_la_resistenza_delle_uova ><a href="#testando_la_resistenza_delle_uova" class=header-anchor >Testando la resistenza delle uova</a></h2> <p>Immaginate di essere un allevatore che, incrociando varie razze di gallina, è riuscito ad ottenerne una che depone delle uova particolarmente forti. Volete quindi testare di preciso quanto siano resistenti queste uova, e per farlo decidete di lanciarle dai vari piani di un edificio di 100 piani con l&#39;obiettivo di trovare il piano più alto da cui un uovo può cadere senza rompersi.</p> <p>Se aveste un solo uovo sapreste subito come fare: lanciate l&#39;uovo dal primo piano, se non si rompe passate al secondo, se non si rompe ancora passate al terzo, poi al quarto, e così via, fino a incontrare il primo piano in cui si rompe &#40;o non incontrarne nessuno nel caso in cui anche al 100esimo piano l&#39;uovo non si rompa&#41;. Ci vorrebbero, nel caso peggiore, 100 lanci per trovare la soluzione. </p> <p>Ma ora supponiamo che voi abbiate 2 uova. Quale strategia utilizzereste ora per trovare la risposta in modo da minimizzare il caso peggiore del numero di lanci da effettuare?<br />Supponete infine di avere <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> uova. Quale strategia utilizzereste, in questo caso? &#40;sempre per minimizzare il caso peggiore del numero di lanci da effettuare&#41;</p> <img src="/assets/img/gallina2_cut.png" alt=""> <blockquote> <p>Problema ispirato da <a href="https://plus.maths.org/content/dropping-eggs">https://plus.maths.org/content/dropping-eggs</a> e da <a href="https://spencermortensen.com/articles/egg-problem/">https://spencermortensen.com/articles/egg-problem/</a></p> </blockquote> <h2 id=soluzione_intuitiva ><a href="#soluzione_intuitiva" class=header-anchor >Soluzione intuitiva</a></h2> <p>Chiamiamo &quot;piano critico&quot; il massimo piano da cui l&#39;uovo può essere lanciato senza che si rompa. Il nostro obiettivo è trovare la strategia che individui questo piano critico minimizzando il <em>numero massimo di lanci</em> da effettuare <em>nel caso peggiore</em>. In altri termini, il metodo che alla peggio ci metta meno lanci.</p> <p>Se avessimo un solo uovo, saremmo forzati a testare un piano per volta partendo dal primo, come descritto nel testo. In questo modo, alla peggio ci metteremo 100 lanci per trovare il piano critico &#40;il caso peggiore è infatti se il piano critico è proprio il piano 100&#41;.</p> <p>Invece, con due uova, l&#39;idea è che possiamo permetterci di partire lanciando il primo uovo da piani più alti, investendolo cioè in test più rischiosi in quanto c&#39;è maggiore rischio che si rompi, ma che poi riducano lo spazio di ricerca su cui impiegare il secondo uovo. Nel caso di rottura del primo uovo, infatti, ritorneremo al caso di un solo uovo e saremo nuovamente costretti a testare un piano per volta, ma impiegando questa strategia ci saremo garantiti una finestra di ricerca ora molto più ristretta rispetto all&#39;originale <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >[</mo><mn>0</mn><mo separator=true >,</mo><mn>100</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">[0,100]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >0</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord >100</span><span class=mclose >]</span></span></span></span>. Il punto è: da quanto in alto far saltare il primo uovo? e se non si rompe, di quanto salire per i lanci successivi?</p> <p>Per esempio, consideriamo la strategia di partire lanciando il primo uovo dal piano 20, con incrementi successivi, in caso di integrità, di 20 piani &#40;ovvero, se non si rompe passare al 40, poi al 60, all&#39;80, e infine al 100&#41;. In questo modo, se l&#39;uovo si rompesse al primo lancio impiegheremo il secondo sulla finestra di piani identificata come rilevante, ovvero <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >[</mo><mn>0</mn><mo separator=true >,</mo><mn>19</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">[0,19]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >0</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord >19</span><span class=mclose >]</span></span></span></span>, in quanto di sicuro lì apparterrà il piano critico. Se si rompesse invece al secondo lancio, dal piano 40, ci concentreremo sulla nuova finestra <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >[</mo><mn>21</mn><mo separator=true >,</mo><mn>39</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">[21,39]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >21</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord >39</span><span class=mclose >]</span></span></span></span>, e così via. Con questo metodo, il caso peggiore sarebbe quello in cui il piano critico è il 99 &#40;o anche il 100&#41;, che comporterebbe 5 lanci col primo uovo &#40;20, 40, 60, 80, 100&#41; e 19 col secondo uovo &#40;dall&#39;81 al 99&#41;. </p> <p>Segue un esempio di esecuzione della strategia appena descritta:</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > stratk([<span class=hljs-number >20</span>,<span class=hljs-number >1</span>],<span class=hljs-number >99</span>,<span class=hljs-literal >true</span>,decrement=<span class=hljs-literal >false</span>)
</span>jump size = 20, 🏯=20 , 🥚=2 , 🪜=1
jump size = 20, 🏯=40 , 🥚=2 , 🪜=2
jump size = 20, 🏯=60 , 🥚=2 , 🪜=3
jump size = 20, 🏯=80 , 🥚=2 , 🪜=4
jump size = 20, 🏯=100, 🥚=1 , 🪜=5
jump size = 1 , 🏯=81 , 🥚=1 , 🪜=6
jump size = 1 , 🏯=82 , 🥚=1 , 🪜=7
jump size = 1 , 🏯=83 , 🥚=1 , 🪜=8
jump size = 1 , 🏯=84 , 🥚=1 , 🪜=9
jump size = 1 , 🏯=85 , 🥚=1 , 🪜=10
jump size = 1 , 🏯=86 , 🥚=1 , 🪜=11
jump size = 1 , 🏯=87 , 🥚=1 , 🪜=12
jump size = 1 , 🏯=88 , 🥚=1 , 🪜=13
jump size = 1 , 🏯=89 , 🥚=1 , 🪜=14
jump size = 1 , 🏯=90 , 🥚=1 , 🪜=15
jump size = 1 , 🏯=91 , 🥚=1 , 🪜=16
jump size = 1 , 🏯=92 , 🥚=1 , 🪜=17
jump size = 1 , 🏯=93 , 🥚=1 , 🪜=18
jump size = 1 , 🏯=94 , 🥚=1 , 🪜=19
jump size = 1 , 🏯=95 , 🥚=1 , 🪜=20
jump size = 1 , 🏯=96 , 🥚=1 , 🪜=21
jump size = 1 , 🏯=97 , 🥚=1 , 🪜=22
jump size = 1 , 🏯=98 , 🥚=1 , 🪜=23
jump size = 1 , 🏯=99 , 🥚=1 , 🪜=24</code></pre> <p>Questa strada sembra in effetti sensata, ma per arrivare a quella ottimale occorre eseguire un ultimo passettino. Notiamo infatti che, col metodo appena descritto nell&#39;esempio, la finestra di ricerca per il secondo uovo rimane fissa, costantemente ampia 19 piani. Tuttavia, ogni volta che il primo uovo non si rompe, stiamo di fatto sprecando dei lanci, che si andranno ad aggiungere al conteggio totale dei lanci effettuati. Perciò qui arriva l&#39;ideona: se anziché saltare di un numero fisso di piani &#40;di 20 in 20&#41;, saltassimo con salti decrescenti &#40;di 20, poi 19, poi 18, ecc&#41;? In questo modo, più test effettuiamo col primo uovo, più la finestra di ricerca si restringe col secondo uovo man mano che saliamo, compensando l&#39;aver investito per più lanci il primo uovo. </p> <p>Notiamo infatti già un bell&#39;effetto impostando, nella funzione precedente, il parametro <code>decrement</code> su <code>true</code> in modo da scalare di uno l&#39;ampiezza dei salti effettuati col primo uovo: </p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > stratk([<span class=hljs-number >20</span>,<span class=hljs-number >1</span>],<span class=hljs-number >99</span>,<span class=hljs-literal >true</span>,decrement=<span class=hljs-literal >true</span>)
</span>jump size = 20, 🏯=20 , 🥚=2 , 🪜=1
jump size = 19, 🏯=39 , 🥚=2 , 🪜=2
jump size = 18, 🏯=57 , 🥚=2 , 🪜=3
jump size = 17, 🏯=74 , 🥚=2 , 🪜=4
jump size = 16, 🏯=90 , 🥚=2 , 🪜=5
jump size = 15, 🏯=100, 🥚=1 , 🪜=6
jump size = 1 , 🏯=91 , 🥚=1 , 🪜=7
jump size = 1 , 🏯=92 , 🥚=1 , 🪜=8
jump size = 1 , 🏯=93 , 🥚=1 , 🪜=9
jump size = 1 , 🏯=94 , 🥚=1 , 🪜=10
jump size = 1 , 🏯=95 , 🥚=1 , 🪜=11
jump size = 1 , 🏯=96 , 🥚=1 , 🪜=12
jump size = 1 , 🏯=97 , 🥚=1 , 🪜=13
jump size = 1 , 🏯=98 , 🥚=1 , 🪜=14
jump size = 1 , 🏯=99 , 🥚=1 , 🪜=15</code></pre> <p>Con questa strategia &#40;salto iniziale ampio 20 e decrementi di 1 ogni volta che si sale&#41; ci metteremmo alla peggio 20 lanci. Magari possiamo fare di meglio, scegliendo un salto diverso da 20? In effetti sì.<br />Per trovare questo valore di salto ottimale, basta pensare che più saliamo, più vogliamo restringere la nostra finestra di ricerca, in modo da compensare tutti i lanci effettuati per arrivarci, ma comunque dobbiamo garantirci di esplorare l&#39;intero spazio dei piani da 1 a 100, in quanto il piano critico potrebbe ovviamente essere anche uno degli ultimi.</p> <p>Un salto ampio 20 era in effetti eccessivo, perché decrementandolo con 19, 18, ecc, riusciremmo ad esplorare un numero di piani pari a <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mo>+</mo><mn>19</mn><mo>+</mo><mn>18</mn><mo>+</mo><mo>…</mo><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>210</mn></mrow><annotation encoding="application/x-tex">20+19+18+\ldots+2+1=210</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7278em;vertical-align:-0.0833em;"></span><span class=mord >20</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.7278em;vertical-align:-0.0833em;"></span><span class=mord >19</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.7278em;vertical-align:-0.0833em;"></span><span class=mord >18</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6667em;vertical-align:-0.0833em;"></span><span class=minner >…</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.7278em;vertical-align:-0.0833em;"></span><span class=mord >2</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >1</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >210</span></span></span></span>, che sono in effetti fin troppi per il nostro edificio di 100 piani. Il calcolo mostra quindi che se l&#39;edificio avesse 210 piani, 20 sarebbe stato il valore ottimale in quel caso. Con 100 piani, invece, il salto ottimale <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> sarà quindi il più basso valore tale per cui </p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>n</mi><mo>+</mo><mo stretchy=false >(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=false >)</mo><mo>+</mo><mo stretchy=false >(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy=false >)</mo><mo>+</mo><mo>…</mo><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>≥</mo><mn>100</mn></mrow><annotation encoding="application/x-tex"> n+(n-1)+(n-2)+\ldots+2+1 \geq 100 </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >1</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >2</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6667em;vertical-align:-0.0833em;"></span><span class=minner >…</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.7278em;vertical-align:-0.0833em;"></span><span class=mord >2</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.7804em;vertical-align:-0.136em;"></span><span class=mord >1</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >≥</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >100</span></span></span></span></span> <p>ovvero </p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mfrac><mrow><mi>n</mi><mo stretchy=false >(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=false >)</mo></mrow><mn>2</mn></mfrac><mo>≥</mo><mn>100</mn><mtext> </mtext><mo>⟹</mo><mtext> </mtext><mi>n</mi><mo>=</mo><mn>14</mn></mrow><annotation encoding="application/x-tex"> \frac{n(n+1)}{2} \geq 100 \implies n=14 </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:2.113em;vertical-align:-0.686em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.427em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >2</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mord >1</span><span class=mclose >)</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >≥</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6684em;vertical-align:-0.024em;"></span><span class=mord >100</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >⟹</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >14</span></span></span></span></span> <p>Perciò con salti decrementati a partire da 14, e un edificio di 100 piani, alla peggio ci metteremo 14 lanci, e questa è la strategia ottimale.</p> <p>Giusto per ricapitolare l&#39;idea del compensare i lanci, questo sarebbe lo schemino di esecuzione da seguire.</p> <ul> <li><p>Lanciamo il primo uovo dal piano 14: se si rompe, controlliamo col secondo uovo i tredici piani dall&#39;1 al 13 &#40;alla peggio ci avremmo messo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>13</mn><mo>=</mo><mn mathvariant=bold >14</mn></mrow><annotation encoding="application/x-tex">1+13=\bf{14}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7278em;vertical-align:-0.0833em;"></span><span class=mord >1</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >13</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord ><span class=mord ><span class="mord mathbf">14</span></span></span></span></span></span> lanci&#41;; se non si rompe,</p> <li><p>lanciamo il primo uovo dal piano <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>14</mn><mo>+</mo><mn>13</mn><mo>=</mo><mn>27</mn></mrow><annotation encoding="application/x-tex">14+13=27</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7278em;vertical-align:-0.0833em;"></span><span class=mord >14</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >13</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >27</span></span></span></span>: se si rompe, controlliamo col secondo uovo i dodici piani dal 15 al 26 &#40;alla peggio ci avremmo messo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>+</mo><mn>12</mn><mo>=</mo><mn mathvariant=bold >14</mn></mrow><annotation encoding="application/x-tex">2+12=\bf{14}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7278em;vertical-align:-0.0833em;"></span><span class=mord >2</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >12</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord ><span class=mord ><span class="mord mathbf">14</span></span></span></span></span></span> lanci&#41;; se non si rompe,</p> <li><p>lanciamo il primo uovo dal piano <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>14</mn><mo>+</mo><mn>13</mn><mo>+</mo><mn>12</mn><mo>=</mo><mn>39</mn></mrow><annotation encoding="application/x-tex">14+13+12=39</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7278em;vertical-align:-0.0833em;"></span><span class=mord >14</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.7278em;vertical-align:-0.0833em;"></span><span class=mord >13</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >12</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >39</span></span></span></span>: se si rompe, controlliamo col secondo uovo gli undici piani dal 28 al 38 &#40;alla peggio ci avremmo messo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>+</mo><mn>11</mn><mo>=</mo><mn mathvariant=bold >14</mn></mrow><annotation encoding="application/x-tex">3+11=\bf{14}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7278em;vertical-align:-0.0833em;"></span><span class=mord >3</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >11</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord ><span class=mord ><span class="mord mathbf">14</span></span></span></span></span></span> lanci&#41;; se non si rompe,</p> <li><p>ecc</p> </ul> <div id=fdpmhd  style=""></div> <script> graphDiv = document.getElementById("fdpmhd"); plotlyPromise = PlotlyJS_json(graphDiv, '/assets/scripts/output/eggs_hist.json'); </script> <p>Questa idea di fare passi decrescenti si può naturalmente estendere ai casi con più uova, ma se per due uova era la soluzione ottimale, non è detto che lo rimanga nel caso di tre o più uova. Infatti, si può trovare un metodo migliore, per vie più rigorose, che consente di risolvere <em>sempre</em> il problema in maniera ottimale anche considerando un numero arbitrario di piani <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> e di uova <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>. A tal proposito, per questa soluzione matematica vi rinvio al paragrafo quindi <a href="#soluzione_matematica">qui</a> sotto, subito dopo la digressione informatica legata a questo metodo &quot;intuitivo&quot;.</p> <hr /> <p>La funzione che segue simula l&#39;esecuzione del lancio di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> uova, usando un <em>jump&#95;size</em> diverso in funzione del numero di uova rimaste. Per esempio, <code>strat_vector &#61; &#91;14,1&#93;</code> corrisponde al caso in cui abbiamo 2 uova, e finché ne abbiamo due saltiamo di 14 piani, poi 13, 12, ecc &#40;se anche il parametro <code>decrement</code> è impostato su <code>true</code>, altrimenti l&#39;ampiezza dei salti resta invariata, ovvero saltiamo di 14 piani, poi ancora 14, 14, ecc&#41;, mentre quando ci rimane un solo uovo allora facciamo passi alti sempre 1. Mentre <code>strat_vector &#61; &#91;18,7,1&#93;</code> corrisponde alla simulazione in cui abbiamo 3 uova, e se ne finché ne abbiamo tre effettuiamo salti alti 18, poi 17, 16, ecc; quando ne abbbiamo due salti alti 7, poi 6, 5, ecc &#40;sempre nel caso <code>decrement&#61;true</code>&#41;; e infine quando ne abbbiamo solo uno passiamo a salti alti 1.</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> the_egg_breaks(testing_floor, critical_floor)
  <span class=hljs-keyword >return</span> testing_floor&gt;critical_floor
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> print_summary(eggs::<span class=hljs-built_in >Integer</span>,floor::<span class=hljs-built_in >Integer</span>,steps::<span class=hljs-built_in >Integer</span>,jump_size::<span class=hljs-built_in >Integer</span>,solution)
  println(<span class=hljs-string >&quot;jump size = <span class=hljs-subst >$(rpad(jump_size,<span class=hljs-number >2</span>)</span>), &quot;</span>,
      <span class=hljs-string >&quot;🏯=<span class=hljs-subst >$(rpad(string(floor)</span>,3)), &quot;</span>,
      <span class=hljs-string >&quot;🥚=<span class=hljs-subst >$(rpad(string(eggs)</span>,2)), &quot;</span>,
      <span class=hljs-string >&quot;🪜=<span class=hljs-subst >$(rpad(string(steps)</span>,2))&quot;</span>)
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> foundable(solution::<span class=hljs-built_in >Vector</span>, verbose=<span class=hljs-literal >false</span>)
  <span class=hljs-comment ># if verbose println(join(map(string, solution))); end</span>
  <span class=hljs-comment ># 2 was the default value</span>
  <span class=hljs-comment ># 1 is for floors where the egg breaks</span>
  <span class=hljs-comment ># 0 is for floors where the egg does not break</span>
  <span class=hljs-keyword >return</span> occursin(<span class=hljs-string >&quot;01&quot;</span>,join(map(string, solution))) || join(map(string, solution)) == repeat(<span class=hljs-string >&#x27;0&#x27;</span>,<span class=hljs-number >100</span>)
  <span class=hljs-comment ># all&#x27;inizio solution era un vettore di soli 2: 22222...22222</span>
  <span class=hljs-comment ># lanciando le uova identifichiamo le zone in cui si rompe (1) o resta integro (0)</span>
  <span class=hljs-comment ># quindi il piano critico si può individueare se</span>
  <span class=hljs-comment ># - incontriamo un pezzo &quot;01&quot; nella stringa solution (prima parte del return); o</span>
  <span class=hljs-comment ># - se da nessun piano l&#x27;uovo cadendo si rompe (seconda parte del return)</span>
<span class=hljs-keyword >end</span>


<span class=hljs-keyword >function</span> stratk(divs_strat::<span class=hljs-built_in >Vector</span>, critical_floor::<span class=hljs-built_in >Integer</span>, verbose::<span class=hljs-built_in >Bool</span>; decrement=<span class=hljs-literal >true</span>)
  solution = <span class=hljs-number >2</span> .* ones(<span class=hljs-built_in >Int</span>,<span class=hljs-number >100</span>)
  eggs = length(divs_strat)
  steps = <span class=hljs-number >0</span>
  strats = reverse(copy(divs_strat))
  previous_floor = <span class=hljs-number >0</span>
  current_floor = strats[<span class=hljs-keyword >end</span>]
  jump_size = strats[eggs]

  <span class=hljs-keyword >while</span> !foundable(solution,verbose) &amp;&amp; steps&lt;=<span class=hljs-number >100</span>
    interval_focus = findlast(x-&gt;x==<span class=hljs-string >&#x27;2&#x27;</span>,join(map(string, solution))) - 
             findfirst(x-&gt;x==<span class=hljs-string >&#x27;2&#x27;</span>,join(map(string, solution))) + <span class=hljs-number >1</span>
    eggs&lt;<span class=hljs-number >1</span> &amp;&amp; <span class=hljs-keyword >return</span> <span class=hljs-literal >NaN</span>
    jump_size&lt;<span class=hljs-number >1</span> &amp;&amp; <span class=hljs-keyword >return</span> <span class=hljs-literal >NaN</span>
    current_floor&lt;<span class=hljs-number >1</span> &amp;&amp; <span class=hljs-keyword >return</span> <span class=hljs-literal >NaN</span>
    <span class=hljs-comment ># current_floor=min(current_floor,100)</span>

    <span class=hljs-keyword >if</span> isnothing(findlast(x-&gt;x==<span class=hljs-string >&#x27;1&#x27;</span>,join(map(string,solution))))
      max_index = <span class=hljs-number >100</span>
    <span class=hljs-keyword >else</span>
      max_index = findlast(x-&gt;x==<span class=hljs-string >&#x27;1&#x27;</span>,join(map(string,solution)))-<span class=hljs-number >1</span>
    <span class=hljs-keyword >end</span>
    current_floor=min(current_floor,max_index)
  
    <span class=hljs-keyword >if</span> the_egg_breaks(current_floor, critical_floor)
      <span class=hljs-comment ># se l&#x27;uovo si è rotto aggiorniamo solution segnandoci che si romperebbe da lì in poi,</span>
      eggs -= <span class=hljs-number >1</span>
      steps += <span class=hljs-number >1</span>
      solution[current_floor:<span class=hljs-keyword >end</span>] .= <span class=hljs-number >1</span>
      <span class=hljs-keyword >if</span> verbose print_summary(eggs,current_floor,steps,jump_size,solution); <span class=hljs-keyword >end</span>
      <span class=hljs-comment ># torniamo all&#x27;ultimo &quot;checkpoint&quot;,</span>
      current_floor = previous_floor +<span class=hljs-number >1</span>
      <span class=hljs-comment ># e aggiorniamo il jump_size</span>
      jump_size = eggs&gt;=<span class=hljs-number >1</span> ? strats[eggs] : <span class=hljs-number >1</span>
    <span class=hljs-keyword >else</span>
      <span class=hljs-comment ># se l&#x27;uovo non si è rotto aggiorniamo solution segnandoci che non si rompe fino a lì,</span>
      solution[<span class=hljs-number >1</span>:current_floor] .= <span class=hljs-number >0</span>
      steps += <span class=hljs-number >1</span>
      <span class=hljs-keyword >if</span> verbose print_summary(eggs,current_floor,steps,jump_size,solution); <span class=hljs-keyword >end</span>
      <span class=hljs-comment ># aggiorniamo jump_size, se necessario,</span>
      <span class=hljs-keyword >if</span> (eggs&gt;<span class=hljs-number >1</span> || jump_size&gt;<span class=hljs-number >1</span>) &amp;&amp; decrement jump_size -= <span class=hljs-number >1</span> <span class=hljs-keyword >end</span>
      <span class=hljs-comment ># salviamo il piano corrente,</span>
      previous_floor = current_floor
      <span class=hljs-comment ># e passiamo al prossimo piano da testare</span>
      current_floor += jump_size
    <span class=hljs-keyword >end</span>
  <span class=hljs-keyword >end</span>
  <span class=hljs-keyword >return</span> steps
<span class=hljs-keyword >end</span></code></pre> <p>Ecco degli esempi di alcune esecuzioni</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > stratk([<span class=hljs-number >14</span>,<span class=hljs-number >1</span>],<span class=hljs-number >58</span>,<span class=hljs-literal >true</span>,decrement=<span class=hljs-literal >true</span>) 
</span>jump size = 14, 🏯=14 , 🥚=2 , 🪜=1 # with 2 eggs
jump size = 13, 🏯=27 , 🥚=2 , 🪜=2
jump size = 12, 🏯=39 , 🥚=2 , 🪜=3
jump size = 11, 🏯=50 , 🥚=2 , 🪜=4
jump size = 10, 🏯=60 , 🥚=1 , 🪜=5
jump size = 1 , 🏯=51 , 🥚=1 , 🪜=6
jump size = 1 , 🏯=52 , 🥚=1 , 🪜=7
jump size = 1 , 🏯=53 , 🥚=1 , 🪜=8
jump size = 1 , 🏯=54 , 🥚=1 , 🪜=9
jump size = 1 , 🏯=55 , 🥚=1 , 🪜=10
jump size = 1 , 🏯=56 , 🥚=1 , 🪜=11
jump size = 1 , 🏯=57 , 🥚=1 , 🪜=12
jump size = 1 , 🏯=58 , 🥚=1 , 🪜=13
jump size = 1 , 🏯=59 , 🥚=0 , 🪜=14
14

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > stratk([<span class=hljs-number >18</span>,<span class=hljs-number >7</span>,<span class=hljs-number >1</span>],<span class=hljs-number >58</span>,<span class=hljs-literal >true</span>,decrement=<span class=hljs-literal >true</span>)
</span>jump size = 18, 🏯=18 , 🥚=3 , 🪜=1 # with three eggs
jump size = 17, 🏯=35 , 🥚=3 , 🪜=2
jump size = 16, 🏯=51 , 🥚=3 , 🪜=3
jump size = 15, 🏯=66 , 🥚=2 , 🪜=4
jump size = 7 , 🏯=52 , 🥚=2 , 🪜=5
jump size = 6 , 🏯=58 , 🥚=2 , 🪜=6
jump size = 5 , 🏯=63 , 🥚=1 , 🪜=7
jump size = 1 , 🏯=59 , 🥚=0 , 🪜=8
8</code></pre> <p>e dei grafici riguardo ai casi migliori, peggiori, e medi di esecuzione delle varie strategie, nella forma <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >[</mo><mi>x</mi><mo separator=true >,</mo><mi>y</mi><mo separator=true >,</mo><mn>1</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">[x,y,1]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class="mord mathnormal">x</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord >1</span><span class=mclose >]</span></span></span></span> seguendo la convenzione introdotta dalla funzione precedente, con quindi tre uova.</p> <div id=fdpujr  style=""></div> <script> graphDiv = document.getElementById("fdpujr"); plotlyPromise = PlotlyJS_json(graphDiv, '/assets/scripts/output/dropping_eggs_all.json'); </script> <h2 id=soluzione_matematica ><a href="#soluzione_matematica" class=header-anchor >Soluzione matematica</a></h2> <p>da scrivere</p> <script src="https://giscus.app/client.js" data-repo="federicomor/federicomor.github.io" data-repo-id=R_kgDOLBdBYA  data-category=Announcements  data-category-id=DIC_kwDOLBdBYM4Clm0M  data-mapping=url  data-strict=0  data-reactions-enabled=1  data-emit-metadata=0  data-input-position=bottom  data-theme=preferred_color_scheme  data-lang=it  // data-loading=lazy  crossorigin=anonymous  async> </script> <div class=page-foot > Last modified: April 07, 2025. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the lovely <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>