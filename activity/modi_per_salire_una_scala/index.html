<!doctype html> <html lang=en > <a id=top ></a> <link rel=icon  href="/assets/favicon.png"> <link rel=icon  type="image/x-icon" href="/assets/favicon.png"> <link rel=icon  type="image/png" href="/assets/favicon.png"/> <link rel=icon  href="/assets/main img.jpg"> <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <link rel=stylesheet  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_hyde.css"> <link rel=icon  href="/assets/favicon.png"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <title>Modi per salire una scala</title> <!-- <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { console.log("url: ",url); console.log("div: ",div); response = await fetch(url); fig = await response.json(); if (typeof fig.config === 'undefined') { fig["config"]={} } delete fig.layout.width delete fig.layout.height fig["layout"]["autosize"] = true fig["config"]["autosizable"] = true fig["config"]["responsive"] = true fig.config["scrollZoom"] = false delete fig.config.staticPlot delete fig.config.displayModeBar delete fig.config.doubleClick delete fig.config.showTips Plotly.newPlot(div, fig); }; </script> --> <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { response = await fetch(url); fig = await response.json(); Plotly.newPlot(div, fig); }; </script> <!-- <a class=backToTopBtn  title="back to top // torna in cima" href="#top"> <span class=backToTopBtn-icon >^</span> </a> --> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <!-- <h1><a href="/">Hyde</a></h1> <p class=lead >A two-column theme.</p> --> <h1><a href="/">Eccoci.<img style="display: block; margin: 0 auto; margin-bottom: 20px"; width=170 ; src="/assets/main img.jpg" alt="main img"/></a></h1> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/">Home</a> <a class="sidebar-nav-item " href="/activity/">Attività</a> <a class="sidebar-nav-item " href="/uni/">Uni</a> <a class="sidebar-nav-item " href="/portfolio/">Portfolio</a> </nav> <a href="https://www.youtube.com/channel/UC1_68R2Kv1htcZ1It5il7CQ" target=_blank rel=noopener> <i class="fab fa-youtube big-icon"></i></a> <a href="https://www.instagram.com/divergentissimo/" target=_blank rel=noopener> <i class="fab fa-instagram big-icon"></i></a> <a href="https://www.linkedin.com/in/federico-angelo-mor/" target=_blank rel=noopener> <i class="fab fa-linkedin big-icon"></i></a> <a href="https://github.com/federicomor" target=_blank rel=noopener> <i class="fab fa-github big-icon"></i></a> </div> </div> <div class="content container"> <a class=backToTopBtn  title="back to top // torna in cima" href="#top"> <span class=backToTopBtn-icon >∧</span> </a> <div class=franklin-content > <h2 id=modi_per_salire_una_scala ><a href="#modi_per_salire_una_scala" class=header-anchor >Modi per salire una scala</a></h2> <p>In quanti modi si può salire una scala lunga \(n\) gradini, potendo salire al massimo 2 scalini per volta? E salendone al massimo \(k\) per volta?</p> <p></p> <iframe width="80%" style="aspect-ratio:16/9; margin: auto;" src="https://www.youtube.com/embed/HWJOsKOcUJk?rel=0"> </iframe> <p></p> <blockquote> <p>Problema ispirato da <a href="https://plus.maths.org/content/its-long-way-top">https://plus.maths.org/content/its-long-way-top</a>.</p> </blockquote> <h2 id=soluzione ><a href="#soluzione" class=header-anchor >Soluzione</a></h2> <p>Partiamo dal caso in cui possiamo fare al massimo due scalini per volta. Chiamando \(S(n)\) questo numero di modi in funzione di \(n\), risulta che la soluzione è data da</p> \[ S(n) = S(n-1) + S(n-2) \] <p>perché moralmente come primo passo dobbiamo sempre fare un passo lungo 1 o lungo 2, indipendentemente da quanto la scala sia alta, e da quei passi poi possiamo osservare di fronte a noi una scala o alta \(n-1\) o alta \(n-2\) scalini, rispettivamente, e quindi riciclare i calcoli già fatti prima per le altre scale. Quindi è una formula ricorsiva, in cui i calcoli per \(n\) più alti si appoggiano ai calcoli fatti per gli \(n\) più bassi, dove come casi base abbiamo che una scala alta uno la possiamo salire in un solo modo, e quindi \(S(1)=1\), mentre una scala alta due la possiamo salire in due soli modi, e quindi \(S(2)=2\).</p> <p>Mentre generalizzando il calcolo, supponendo cioè di avere un altro parametro \(k\) che regola quanti scalini riusciamo a salire al massimo con un solo passo, la soluzione diventa</p> \[ S(n) = S(n-1) + S(n-2) + \ldots + S(n-k) \] <p>dove però ora i vari valori \(S(n-i)\) si devono trovare in modi a volte meno ovvi. Per capire tutto, insieme ad una semplice idea per convertire il calcolo in codice eseguibile da un computer, vi rimando naturalmente al video.</p> <pre><code class=language-julia >using Plots

function S&#40;n,k&#41;
	n&#61;&#61;0 &amp;&amp; return 0
	n&#61;&#61;1 &amp;&amp; return 1
	if n&lt;k 
		return S&#40;n,n&#41;
	elseif n&#61;&#61;k
		return S&#40;n,k-1&#41;&#43;1
	else # n&gt;k
		return sum&#40;S&#40;n-i,k&#41; for i in 1:k&#41;
	end
end

scale &#61; 1:14
modi_1 &#61; S.&#40;scale,1&#41;
modi_2 &#61; S.&#40;scale,2&#41;
modi_3 &#61; S.&#40;scale,3&#41;
modi_4 &#61; S.&#40;scale,4&#41;
modi_5 &#61; S.&#40;scale,5&#41;

plot&#40;scale, modi_1, marker&#61;:circle, line&#61;:solid, label&#61;&quot;k&#61;1&quot;, legend&#61;:left&#41;
plot&#33;&#40;scale, modi_2, marker&#61;:circle, line&#61;:solid, label&#61;&quot;k&#61;2&quot;&#41;
plot&#33;&#40;scale, modi_3, marker&#61;:circle, line&#61;:solid, label&#61;&quot;k&#61;3&quot;&#41;
plot&#33;&#40;scale, modi_4, marker&#61;:circle, line&#61;:solid, label&#61;&quot;k&#61;4&quot;&#41;
plot&#33;&#40;scale, modi_5, marker&#61;:circle, line&#61;:solid, label&#61;&quot;k&#61;5&quot;&#41;

plot&#33;&#40;xticks&#61;collect&#40;scale&#41;&#41;
xlabel&#33;&#40;&quot;Gradini&quot;&#41;
ylabel&#33;&#40;&quot;Modi&quot;&#41;
title&#33;&#40;&quot;Comparison of S&#40;n, k&#41; for different k values&quot;&#41;</code></pre> <div id=fdpkly  style=""></div> <script> graphDiv = document.getElementById("fdpkly"); plotlyPromise = PlotlyJS_json(graphDiv, '/assets/scripts/output/scale.json'); </script> <label for=inputN >n:</label> <input type=number  id=inputN  min=1 > <label for=inputK >k:</label> <input type=number  id=inputK  min=1 > <button onclick="calculate()">Calcola</button> <div id=result ></div> <script> function S(n, k) { let dp = Array.from({ length: n + 1 }, () => Array(k + 1).fill(0)); for (let j = 1; j <= k; j++) { dp[1][j] = 1; } for (let i = 2; i <= n; i++) { for (let j = 1; j <= k; j++) { if (i < j) { dp[i][j] = dp[i][i]; } else if (i == j) { dp[i][j] = dp[i][j - 1] + 1; } else { dp[i][j] = 0; for (let m = 1; m <= j; m++) { dp[i][j] += dp[i - m][j]; } } } } return dp[n][k]; } function calculate() { let n = parseInt(document.getElementById("inputN").value); let k = parseInt(document.getElementById("inputK").value); let result = S(n, k); document.getElementById("result").innerText = `Risultato: ${result}`; } </script> <br> <p>La scrittura della funzione in forma ricorsiva è utile, didattica, perché rispecchia la soluzione matematica che abbiamo trovato. Tuttavia, per una implementazione più efficiente c&#39;è un altro modo che al posto della ricorsione utilizza una tecnica un po&#39; più avanzata, la memoization, appartenente al mondo del &quot;dynamic programming&quot;. L&#39;idea è infatti che usando la ricorsione molti calcoli vengono ripetuti; in quest&#39;altra versione invece i calcoli vengono salvati e riutilizzati.</p> <pre><code class=language-julia >function S_fast&#40;n, k, memo&#61;Dict&#123;Tuple&#123;Int, Int&#125;, Int&#125;&#40;&#41;&#41;
	# casi base, come prima
	n&#61;&#61;0 &amp;&amp; return 0
	n&#61;&#61;1 &amp;&amp; return 1

	# se il risultato è stato già calcolato, ritornalo
	if haskey&#40;memo, &#40;n, k&#41;&#41;
		return memo&#91;&#40;n, k&#41;&#93;
	end
	# altrimenti calcolalo...
	result &#61; if n &lt; k
		S&#40;n, n, memo&#41;
	elseif n &#61;&#61; k
		S&#40;n, k - 1, memo&#41; &#43; 1
	else
		sum&#40;S&#40;n - i, k, memo&#41; for i in 1:k&#41;
	end
	# ... e salvalo in memo
	memo&#91;&#40;n, k&#41;&#93; &#61; result
	return result
end</code></pre> <p>Questa nuova versione produce infatti un notevole miglioramento delle performance:</p> <pre><code class=language-julia-repl >julia&gt; @time S&#40;32,5&#41;
 19.574231 seconds
1333610936

julia&gt; @time S_fast&#40;32,5&#41;
  0.000019 seconds &#40;58 allocations: 4.156 KiB&#41;
1333610936</code></pre> <script src="https://giscus.app/client.js" data-repo="federicomor/federicomor.github.io" data-repo-id=R_kgDOLBdBYA  data-category=Announcements  data-category-id=DIC_kwDOLBdBYM4Clm0M  data-mapping=url  data-strict=0  data-reactions-enabled=1  data-emit-metadata=0  data-input-position=bottom  data-theme=preferred_color_scheme  data-lang=it  // data-loading=lazy  crossorigin=anonymous  async> </script> <div class=page-foot > Last modified: August 19, 2025. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the lovely <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> <script src="/libs/katex/katex.min.js"></script> <script src="/libs/katex/contrib/auto-render.min.js"></script> <script>renderMathInElement(document.body)</script> <!-- <script> MathJax = { tex: { inlineMath: [['\\(', '\\)']], tags: 'all' }, svg: {fontCache: 'global'} }; </script> <script id=MathJax-script  async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script> --> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>