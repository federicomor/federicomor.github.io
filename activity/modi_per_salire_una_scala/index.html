<!doctype html> <html lang=en > <a id=top ></a> <link rel=icon  href="/assets/favicon.png"> <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { response = await fetch(url); fig = await response.json(); Plotly.newPlot(div, fig); }; </script> <link rel=stylesheet  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_hyde.css"> <link rel=icon  href="/assets/favicon.png"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <title>Modi per salire una scala</title> <!-- <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { console.log("url: ",url); console.log("div: ",div); response = await fetch(url); fig = await response.json(); if (typeof fig.config === 'undefined') { fig["config"]={} } delete fig.layout.width delete fig.layout.height fig["layout"]["autosize"] = true fig["config"]["autosizable"] = true fig["config"]["responsive"] = true fig.config["scrollZoom"] = false delete fig.config.staticPlot delete fig.config.displayModeBar delete fig.config.doubleClick delete fig.config.showTips Plotly.newPlot(div, fig); }; </script> --> <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { response = await fetch(url); fig = await response.json(); Plotly.newPlot(div, fig); }; </script> <!-- <a class=backToTopBtn  title="back to top // torna in cima" href="#top"> <span class=backToTopBtn-icon >^</span> </a> --> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <!-- <h1><a href="/">Hyde</a></h1> <p class=lead >A two-column theme.</p> --> <h1><a href="/">Eccoci.<img style="display: block; margin: 0 auto; margin-bottom: 20px"; width=170 ; src="/assets/main img.jpg" alt="main img"/></a></h1> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/">Home</a> <a class="sidebar-nav-item " href="/activity/">Attività</a> <a class="sidebar-nav-item " href="/tesi/">Tesi</a> <a class="sidebar-nav-item " href="/uni/">Uni</a> </nav> <a href="https://www.youtube.com/@fede_plus" target=_blank rel=noopener> <i class="fab fa-youtube big-icon"></i></a> <a href="https://www.linkedin.com/in/federico-angelo-mor/" target=_blank rel=noopener> <i class="fab fa-linkedin big-icon"></i></a> <a href="https://github.com/federicomor" target=_blank rel=noopener> <i class="fab fa-github big-icon"></i></a> </div> </div> <div class="content container"> <a class=backToTopBtn  title="back to top // torna in cima" href="#top"> <span class=backToTopBtn-icon >∧</span> </a> <div class=franklin-content > <h3 id=modi_per_salire_una_scala ><a href="#modi_per_salire_una_scala" class=header-anchor >Modi per salire una scala</a></h3> <p></p> <iframe width="80%" style="aspect-ratio:16/9; margin: auto;" src="https://www.youtube.com/embed/HWJOsKOcUJk?rel=0"> </iframe> <p></p> <p>In quanti modi si può salire una scala lunga <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> gradini, potendo salire al massimo 2 scalini per volta? E salendone al massimo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> per volta?</p> <blockquote> <p>Problema ispirato da <a href="https://plus.maths.org/content/its-long-way-top">https://plus.maths.org/content/its-long-way-top</a>.</p> </blockquote> <h3 id=soluzione ><a href="#soluzione" class=header-anchor >Soluzione</a></h3> <p>Partiamo dal caso in cui possiamo fare al massimo due scalini per volta. Chiamando <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy=false >(</mo><mi>n</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">S(n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mclose >)</span></span></span></span> questo numero di modi in funzione di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>, risulta che la soluzione è data da</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>S</mi><mo stretchy=false >(</mo><mi>n</mi><mo stretchy=false >)</mo><mo>=</mo><mi>S</mi><mo stretchy=false >(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=false >)</mo><mo>+</mo><mi>S</mi><mo stretchy=false >(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex"> S(n) = S(n-1) + S(n-2) </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >1</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >2</span><span class=mclose >)</span></span></span></span></span> <p>perché moralmente come primo passo dobbiamo sempre fare un passo lungo 1 o lungo 2, indipendentemente da quanto la scala sia alta, e da quei passi poi possiamo osservare di fronte a noi una scala o alta <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >1</span></span></span></span> o alta <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >2</span></span></span></span> scalini, rispettivamente, e quindi riciclare i calcoli già fatti prima per le altre scale. Quindi è una formula ricorsiva, in cui i calcoli per <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> più alti si appoggiano ai calcoli fatti per gli <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> più bassi, dove come casi base abbiamo che una scala alta uno la possiamo salire in un solo modo, e quindi <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy=false >(</mo><mn>1</mn><mo stretchy=false >)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">S(1)=1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mopen >(</span><span class=mord >1</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >1</span></span></span></span>, mentre una scala alta due la possiamo salire in due soli modi, e quindi <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy=false >(</mo><mn>2</mn><mo stretchy=false >)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">S(2)=2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mopen >(</span><span class=mord >2</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >2</span></span></span></span>.</p> <p>Mentre generalizzando il calcolo, supponendo cioè di avere un altro parametro <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> che regola quanti scalini risuciamo a salire al massimo con un solo passo, la soluzione diventa</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>S</mi><mo stretchy=false >(</mo><mi>n</mi><mo stretchy=false >)</mo><mo>=</mo><mi>S</mi><mo stretchy=false >(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=false >)</mo><mo>+</mo><mi>S</mi><mo stretchy=false >(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy=false >)</mo><mo>+</mo><mo>…</mo><mo>+</mo><mi>S</mi><mo stretchy=false >(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex"> S(n) = S(n-1) + S(n-2) + \ldots + S(n-k) </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >1</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >2</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6667em;vertical-align:-0.0833em;"></span><span class=minner >…</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mclose >)</span></span></span></span></span> <p>dove però ora i vari valori <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy=false >(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">S(n-i)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class=mclose >)</span></span></span></span> si devono trovare in modi a volte meno ovvi. Per capire tutto, insieme ad una semplice idea per convertire il calcolo in codice eseguibile da un computer vi rimando naturalmente al video.</p> <p><pre><code class="julia hljs"><span class=hljs-keyword >using</span> Plots

<span class=hljs-keyword >function</span> S(n,k)
	n==<span class=hljs-number >0</span> &amp;&amp; <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>
	n==<span class=hljs-number >1</span> &amp;&amp; <span class=hljs-keyword >return</span> <span class=hljs-number >1</span>
	<span class=hljs-keyword >if</span> n&lt;k 
		<span class=hljs-keyword >return</span> S(n,n)
	<span class=hljs-keyword >elseif</span> n==k
		<span class=hljs-keyword >return</span> S(n,k-<span class=hljs-number >1</span>)+<span class=hljs-number >1</span>
	<span class=hljs-keyword >else</span> <span class=hljs-comment ># n&gt;k</span>
		<span class=hljs-keyword >return</span> sum(S(n-i,k) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:k)
	<span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>

scale = <span class=hljs-number >1</span>:<span class=hljs-number >14</span>
modi_1 = S.(scale,<span class=hljs-number >1</span>)
modi_2 = S.(scale,<span class=hljs-number >2</span>)
modi_3 = S.(scale,<span class=hljs-number >3</span>)
modi_4 = S.(scale,<span class=hljs-number >4</span>)
modi_5 = S.(scale,<span class=hljs-number >5</span>)

plot(scale, modi_1, marker=:circle, line=:solid, label=<span class=hljs-string >&quot;k=1&quot;</span>, legend=:left)
plot!(scale, modi_2, marker=:circle, line=:solid, label=<span class=hljs-string >&quot;k=2&quot;</span>)
plot!(scale, modi_3, marker=:circle, line=:solid, label=<span class=hljs-string >&quot;k=3&quot;</span>)
plot!(scale, modi_4, marker=:circle, line=:solid, label=<span class=hljs-string >&quot;k=4&quot;</span>)
plot!(scale, modi_5, marker=:circle, line=:solid, label=<span class=hljs-string >&quot;k=5&quot;</span>)

plot!(xticks=collect(scale))
xlabel!(<span class=hljs-string >&quot;Gradini&quot;</span>)
ylabel!(<span class=hljs-string >&quot;Modi&quot;</span>)
title!(<span class=hljs-string >&quot;Comparison of S(n, k) for different k values&quot;</span>)</code></pre> <div id=fdpkbt  style=""></div> <script> graphDiv = document.getElementById("fdpkbt"); plotlyPromise = PlotlyJS_json(graphDiv, '/assets/scripts/output/scale.json'); </script> </p> <p>La scrittura della funzione in forma ricorsiva è utile, didattica, perché rispecchia la soluzione matematica che abbiamo trovato. Tuttavia, per una implementazione più efficiente c&#39;è un altro modo, che al posto della ricorsione usa una tecnica un po&#39; più avanzata &#40;memoization&#41; appartenente al mondo del &quot;dynamic programming&quot;. L&#39;idea è infatti che usando la ricorsione molti calcoli vengono ripetuti; in quest&#39;altra versione invece i calcoli vengono salvati e riutilizzati.</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> S_fast(n, k, memo=<span class=hljs-built_in >Dict</span>{<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Int</span>, <span class=hljs-built_in >Int</span>}, <span class=hljs-built_in >Int</span>}())
	<span class=hljs-comment ># casi base, come prima</span>
	n==<span class=hljs-number >0</span> &amp;&amp; <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>
	n==<span class=hljs-number >1</span> &amp;&amp; <span class=hljs-keyword >return</span> <span class=hljs-number >1</span>

	<span class=hljs-comment ># se il risultato è stato già calcolato, ritornalo</span>
	<span class=hljs-keyword >if</span> haskey(memo, (n, k))
		<span class=hljs-keyword >return</span> memo[(n, k)]
	<span class=hljs-keyword >end</span>
	<span class=hljs-comment ># altrimenti calcolalo...</span>
	result = <span class=hljs-keyword >if</span> n &lt; k
		S(n, n, memo)
	<span class=hljs-keyword >elseif</span> n == k
		S(n, k - <span class=hljs-number >1</span>, memo) + <span class=hljs-number >1</span>
	<span class=hljs-keyword >else</span>
		sum(S(n - i, k, memo) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:k)
	<span class=hljs-keyword >end</span>
	<span class=hljs-comment ># ... e salvalo in memo</span>
	memo[(n, k)] = result
	<span class=hljs-keyword >return</span> result
<span class=hljs-keyword >end</span></code></pre> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-meta >@time</span> S(<span class=hljs-number >32</span>,<span class=hljs-number >5</span>)
</span> 19.574231 seconds
1333610936

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-meta >@time</span> S_fast(<span class=hljs-number >32</span>,<span class=hljs-number >5</span>)
</span>  0.000019 seconds (58 allocations: 4.156 KiB)
1333610936</code></pre> <label for=inputN >n:</label> <input type=number  id=inputN  min=1 > <label for=inputK >k:</label> <input type=number  id=inputK  min=1 > <button onclick="calculate()">Calcola</button> <div id=result ></div> <script> function S(n, k) { let dp = Array.from({ length: n + 1 }, () => Array(k + 1).fill(0)); for (let j = 1; j <= k; j++) { dp[1][j] = 1; } for (let i = 2; i <= n; i++) { for (let j = 1; j <= k; j++) { if (i < j) { dp[i][j] = dp[i][i]; } else if (i == j) { dp[i][j] = dp[i][j - 1] + 1; } else { dp[i][j] = 0; for (let m = 1; m <= j; m++) { dp[i][j] += dp[i - m][j]; } } } } return dp[n][k]; } function calculate() { let n = parseInt(document.getElementById("inputN").value); let k = parseInt(document.getElementById("inputK").value); let result = S(n, k); document.getElementById("result").innerText = `Risultato: ${result}`; } </script> <script src="https://giscus.app/client.js" data-repo="federicomor/federicomor.github.io" data-repo-id=R_kgDOLBdBYA  data-category=Announcements  data-category-id=DIC_kwDOLBdBYM4Clm0M  data-mapping=url  data-strict=0  data-reactions-enabled=1  data-emit-metadata=0  data-input-position=bottom  data-theme=preferred_color_scheme  data-lang=it  data-loading=lazy  crossorigin=anonymous  async> </script> <div class=page-foot > Last modified: December 30, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the lovely <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>