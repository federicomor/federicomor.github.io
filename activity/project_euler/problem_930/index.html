<!doctype html> <html lang=en > <a id=top ></a> <link rel=icon  href="/assets/favicon.png"> <link rel=icon  type="image/x-icon" href="/assets/favicon.png"> <link rel=icon  type="image/png" href="/assets/favicon.png"/> <link rel=icon  href="/assets/main img.jpg"> <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { response = await fetch(url); fig = await response.json(); Plotly.newPlot(div, fig); }; </script> <link rel=stylesheet  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_hyde.css"> <link rel=icon  href="/assets/favicon.png"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <title>P930</title> <!-- <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { console.log("url: ",url); console.log("div: ",div); response = await fetch(url); fig = await response.json(); if (typeof fig.config === 'undefined') { fig["config"]={} } delete fig.layout.width delete fig.layout.height fig["layout"]["autosize"] = true fig["config"]["autosizable"] = true fig["config"]["responsive"] = true fig.config["scrollZoom"] = false delete fig.config.staticPlot delete fig.config.displayModeBar delete fig.config.doubleClick delete fig.config.showTips Plotly.newPlot(div, fig); }; </script> --> <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { response = await fetch(url); fig = await response.json(); Plotly.newPlot(div, fig); }; </script> <!-- <a class=backToTopBtn  title="back to top // torna in cima" href="#top"> <span class=backToTopBtn-icon >^</span> </a> --> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <!-- <h1><a href="/">Hyde</a></h1> <p class=lead >A two-column theme.</p> --> <h1><a href="/">Eccoci.<img style="display: block; margin: 0 auto; margin-bottom: 20px"; width=170 ; src="/assets/main img.jpg" alt="main img"/></a></h1> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/">Home</a> <a class="sidebar-nav-item " href="/activity/">Attivit√†</a> <a class="sidebar-nav-item " href="/uni/">Uni</a> <a class="sidebar-nav-item " href="/portfolio/">Portfolio</a> </nav> <a href="https://www.youtube.com/channel/UC1_68R2Kv1htcZ1It5il7CQ" target=_blank rel=noopener> <i class="fab fa-youtube big-icon"></i></a> <a href="https://www.instagram.com/divergentissimo/" target=_blank rel=noopener> <i class="fab fa-instagram big-icon"></i></a> <a href="https://www.linkedin.com/in/federico-angelo-mor/" target=_blank rel=noopener> <i class="fab fa-linkedin big-icon"></i></a> <a href="https://github.com/federicomor" target=_blank rel=noopener> <i class="fab fa-github big-icon"></i></a> </div> </div> <div class="content container"> <a class=backToTopBtn  title="back to top // torna in cima" href="#top"> <span class=backToTopBtn-icon >‚àß</span> </a> <div class=franklin-content > <div class=navigation_symbols > <form action="" method=get  onsubmit="location.href='/activity/project_euler/problem_' + this.elements[0].value; return false;" style="display:inline;"> <input title="go to problem" type="" placeholder=" " required style="margin-right: 5px; width: 40px; padding: 3px; text-align: center; border: 1px solid #666666; border-radius: 4px;"> </form> <a href="/activity/project_euler/problem_929/" style="color: black; text-decoration: none;"><i class="fa-solid fa-arrow-left"></i></a> <a href="javascript:void(0)" onclick="getRandomProblem()" style="color: black; text-decoration: none;" title="random problem">üé≤ </a> <script> function getRandomProblem() { fetch('/activity/project_euler/data.txt') .then(response => response.text()) .then(data => { const maxProblems = parseInt(data.trim(), 10); const randomProblemNumber = Math.floor(Math.random() * maxProblems) + 1; window.location = '/activity/project_euler/problem_' + randomProblemNumber + '/'; }) .catch(err => console.error('Error fetching max problems:', err)); } </script> <a href="/activity/project_euler" style="color: black; text-decoration: none;">üè† </a> <a href="/activity/project_euler/problem_931/" style="color: black; text-decoration: none;"><i class="fa-solid fa-arrow-right"></i></a> </div> <link rel=stylesheet  type="text/css" href="/activity/project_euler/style_main.1735430422.css"> <link rel=stylesheet  type="text/css" href="/activity/project_euler/style_default.1627113674.css"> <script src="https://projecteuler.net/js/mathjax_config.js"></script> <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?version=4.8.0&features=es6"></script> <script id=MathJax-script  async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script> <div id=content > <div class="center print"><img src="https://projecteuler.net/images/clipart/print_page_logo.png" alt=projecteuler.net ></div> <h2>The Gathering</h2><div id=problem_icons  class=noprint ><span class=tooltip >‚ÑπÔ∏è<span class=tooltiptext_right >Published on Sunday, 2nd February 2025, 10:00 am; Solved by 97</span></span></div><div id=problem_info ><h3><a href="https://projecteuler.net/problem=930">Problem 930</a></h3></div> <div class=problem_content  role=problem > <p>Given $n\ge 2$ bowls arranged in a circle, $m\ge 2$ balls are distributed amongst them.</p> <p>Initially the balls are distributed randomly: for each ball, a bowl is chosen equiprobably and independently of the other balls. After this is done, we start the following process:</p> <ol> <li>Choose one of the $m$ balls equiprobably at random. <li>Choose a direction to move - either clockwise or anticlockwise - again equiprobably at random. <li>Move the chosen ball to the neighbouring bowl in the chosen direction. <li>Return to step 1. </ol> <p>This process stops when all the $m$ balls are located in the same bowl. Note that this may be after zero steps, if the balls happen to have been initially distributed all in the same bowl.</p> <p>Let $F(n, m)$ be the expected number of times we move a ball before the process stops. For example, $F(2, 2) = \frac{1}{2}$, $F(3, 2) = \frac{4}{3}$, $F(2, 3) = \frac{9}{4}$, and $F(4, 5) = \frac{6875}{24}$.</p> <p>Let $G(N, M) = \sum_{n=2}^N \sum_{m=2}^M F(n, m)$. For example, $G(3, 3) = \frac{137}{12}$ and $G(4, 5) = \frac{6277}{12}$. You are also given that $G(6, 6) \approx 1.681521567954e4$ in scientific format with 12 significant digits after the decimal point.</p> <p>Find $G(12, 12)$. Give your answer in scientific format with 12 significant digits after the decimal point.</p> </div><br> <br> </div> <!--end_content--> <h2 id=soluzione ><a href="#soluzione" class=header-anchor >Soluzione</a></h2> <p>Partiamo caricando tutti gli strumentopoli misteriosi necessari alla soluzione.</p> <pre><code class=language-julia >using Random, LinearAlgebra
using SparseArrays
using DataStructures
using IterativeSolvers
using Plots, GraphRecipes
Random.seed&#33;&#40;31032025&#41;;</code></pre> <p>Per iniziare ad ambientarci nel contesto del problema &#40;ovvero con il meccanismo di spostamento delle palline nelle ciotole, la condizione di terminazione del gioco, ecc&#41; possiamo implementare una semplice simulazione del gioco stesso, osservando quali possibili scenari possono verificarsi.</p> <pre><code class=language-julia ># n bowls, m balls
function simulate_F&#40;n::Int, m::Int; num_trials::Int&#61;10000, verbose&#61;false&#41;
    total_moves &#61; 0
	if verbose num_trials &#61; 1 end

    for _ in 1:num_trials
        # random initial distribution of balls
        balls &#61; rand&#40;1:n, m&#41; # array of size m, each element in 1:n
        # so that each ball i is assigned to the bowl given by balls&#91;i&#93;
        moves &#61; 0

        while length&#40;unique&#40;balls&#41;&#41; &gt; 1 # stop when all balls are in the same bowl
        # and they will be in the same bowl when all the indexes of balls vector will be equal
            ball_idx &#61; rand&#40;1:m&#41; # pick a ball at random
            direction &#61; rand&#40;&#91;-1, 1&#93;&#41; # pick a direction &#40;-1 for counterclockwise, 1 for clockwise&#41;
			if verbose println&#40;&quot;Balls are in bowls: &#36;balls &#40;selected ball: &#36;ball_idx, will move by: &#36;direction&#41;&quot;&#41; end
            balls&#91;ball_idx&#93; &#61; mod1&#40;balls&#91;ball_idx&#93; &#43; direction, n&#41; # move the ball
            # this changes the bowl attribution of ball ball_idx, using mod1 as for the circular structure
            moves &#43;&#61; 1
        end
		total_moves &#43;&#61; moves
		if verbose
			println&#40;&quot;Balls are in bowls: &#36;balls&quot;&#41;
			println&#40;&quot;Total moves: &#36;total_moves&quot;&#41;
		end
    end
    return total_moves / num_trials  # estimate of F&#40;n, m&#41;
end</code></pre><pre><code class="plaintext code-output">simulate_F (generic function with 1 method)</code></pre>
<p>Con questa funzione possiamo o simulare il problema per ottenere una stima pi√π o meno accurata della soluzione:</p>
<pre><code class=language-julia >simulate_F&#40;2, 3, num_trials &#61; 20_000&#41; # soluzione esatta: 9/4 &#61; 2.25</code></pre><pre><code class="plaintext code-output">2.2518</code></pre>
<p>o altrimenti vedere in concreto cosa accade in un&#39;esempio di esecuzione:</p>
<pre><code class=language-julia >simulate_F&#40;4, 3, verbose&#61;true&#41;</code></pre><pre><code class="plaintext code-output">Balls are in bowls: [1, 2, 3] (selected ball: 2, will move by: 1)
Balls are in bowls: [1, 3, 3] (selected ball: 1, will move by: 1)
Balls are in bowls: [2, 3, 3] (selected ball: 3, will move by: 1)
Balls are in bowls: [2, 3, 4] (selected ball: 1, will move by: 1)
Balls are in bowls: [3, 3, 4] (selected ball: 2, will move by: -1)
Balls are in bowls: [3, 2, 4] (selected ball: 1, will move by: 1)
Balls are in bowls: [4, 2, 4] (selected ball: 2, will move by: -1)
Balls are in bowls: [4, 1, 4] (selected ball: 1, will move by: -1)
Balls are in bowls: [3, 1, 4] (selected ball: 1, will move by: 1)
Balls are in bowls: [4, 1, 4] (selected ball: 2, will move by: -1)
Balls are in bowls: [4, 4, 4]
Total moves: 10
10.0</code></pre>
<p>Ma ovviamente questo non ci basta: vogliamo risolvere il problema in modo &#40;matematicamente&#41; esatto. Per farlo, l&#39;idea √® di affidarci alle <em>catene di Markov</em>. Le catene di Markov hanno infatti come principale scopo nella vita quello di poter modellare un contesto stocastico e dinamico, che √® precisamente quello che abbiamo qui: palline, disposte inizialmente in modo casuale, che si muovono nelle ciotole seguendo mosse casuali.</p>
<p>Per caratterizzare una catena di Markov servono due elementi: lo spazio degli stati \(S\), ovvero le configurazioni che pu√≤ assumere il sistema che stiamo modellando, e la matrice di transizione \(P\), le cui componenti \(p_{ij}\) descrivono la probabilit√† che da un certo stato \(i\) ci spostiamo in un altro stato \(j\). L&#39;idea dello &quot;spostarsi tra i vari stati&quot; deriva dal fatto che alla catena di Markov associamo anche una variabile aleatoria \(X_n\) che descrive in quale stato \(i\in S\) ci troveremo all&#39;istante di tempo \(n\in\mathbb{N}_0\). Per esempio: \(X_0\) √® lo stato da cui partiamo, poi al tempo 1 ci sposteremo in un qualche altro stato \(X_1\), poi \(X_2\), e cos√¨ via.</p>
<h3 id=stati ><a href="#stati" class=header-anchor >Stati</a></h3>
<p>In questo problema, una scelta interessante consiste gi√† nel capire come modellare gli stati. Esistono infatti diversi possibili approcci:</p>
<ol>
<li><p>assegnare a ogni pallina un&#39;etichetta corrispondente alla ciotola in cui √® contenuta</p>

<li><p>assegnare ad ogni ciotola il numero di palline che contiene, pensando alle ciotole come disposte in una fila &#40;quindi esiste la &quot;prima&quot; ciotola, la &quot;seconda&quot; ciotola, ecc&#41; ma mantenendo ovviamente la configurazione circolare del problema assumendo che dalla prima ciotola possiamo &quot;andare a sinistra&quot; ed andare nell&#39;ultima ciotola, e viceversa</p>

<li><p>assegnare ad ogni ciotola il numero di palline che contiene, pensando alle ciotole come effettivamente disposte nel cerchio che prevede il testo, quindi accorpando in base alle simmetrie circolari le configurazioni derivate dal metodo del punto 2</p>

</ol>
<p>Per capire meglio, consideriamo lo scenario in cui ci sono 4 ciotole e 2 palline disposte in modo alternato nelle ciotole. Col primo metodo, questa configurazione verrebbe descritta da quattro stati: \(13\), \(24\), \(31\), \(42\); dove \(ij\) starebbe quindi ad indicare la prima pallina nella ciotola numero \(i\) e la seconda pallina nella ciotola numero \(j\). Col secondo metodo, invece, avremmo gli stati \(0101\) oppure \(1010\), mentre solo col terzo metodo saremo in grado di apprezzare la simmetria del problema e avere un unico stato, diciamo \(0101\), che rappresenti perfettamente la situazione. Infatti, gli stati \(0101\) e \(1010\) diventano ora equivalenti, in quest&#39;ultima formulazione, in quanto uno pu√≤ essere ottenuto &quot;facendo scorrere con circolarit√†&quot; l&#39;altro, moralmente.</p>
<p>Ad ogni modo, con \(n\) ciotole ed \(m\) palline, ciascuno di questi metodi prevederebbe una diversa numerosit√† dello spazio degli stati:</p>
<ol>
<li><p>con la prima formulazione avremmo che ogni pallina pu√≤ andare in ciascuna ciotola. Quindi: \(n\) opzioni per \(m\) palline, da cui \(n^m\) stati</p>

<li><p>con la seconda formulazione avremmo che ogni ciotola, disposta in fila, pu√≤ accogliere da zero a \(m\) palline. Pensando di rappresentare ogni pallina come, beh, una pallina &quot;‚àò&quot; ed ogni ciotola come una barra &quot;|&quot; segue che gli stati totali sono i modi in cui possiamo anagrammare la stringa formata da \(m\) palline e \(n-1\) ciotole &#40;il meno uno √® perch√© fissiamo una certa ciotola essere la prima lettera della stringa&#41;<sup id="fnref:1"><a href="#fndef:1" class=fnref >[1]</a></sup>, supponendo che le palline alla destra di una barra corrispondano a quelle che tale ciotola contiene. Per esempio, la stringa &quot;‚àò‚àò||‚àò&quot; corrisponde ad uno scenario con 3 palline e 3 ciotole, dove la prima contiene due palline, la seconda zero, e la terza una. Con questo metodo, si ricava che il numero di stati √® pari, in generale, a </p>

</ol>
\[\frac{(m+n-1)!}{m!(n-1)!}={ m+n-1 \choose m}\]
<ol start=3 >
<li><p>con la terza formulazione pi√π complicata perch√© contiamo come una sola configurazione, per via delle simmetrie, configurazioni precedentemente diverse, il numero degli stati diminuisce ulteriormente. Per sapere di quanto diminuisce... beh, di certo esister√† una formula che, come nei casi precedenti, conti elegantemente gli stati in funzione di \(n\) ed \(m\). Tuttavia stavolta ricavarla √® molto meno immediato, quindi non ci ho badato troppo: la mia natura ingegneristica ha preso il sopravvento e, contento di aver raggiunto il caso ottimale, ho beatamente proseguito col resto del problema senza stare ad indagare troppo questo calcolo</p>

</ol>
<p>Il punto √® infatti che all&#39;aumentare del numero di ciotole e palline, il terzo metodo permette di limitare la numerosit√† degli stati, mantenendo quindi il problema pi√π agilmente risolvibile per un computer. Per esempio, con 12 ciotole e 6 palline, il primo metodo prevederebbe \(12^6=2985984\) stati, il secondo \({17 \choose 6}=12376\), il terzo 561. E siccome in seguito vedremo che ci sar√† da risolvere un sistema, meglio lavorare con sistemi da 561 variabili rispetto che 2985984&#33;<sup id="fnref:2"><a href="#fndef:2" class=fnref >[2]</a></sup>. La formulazione del secondo metodo √® comunque utile a livello umano per raccontare cosa succede, quindi la riprender√≤ comunque, a volte, nel discorso.</p>
<p><table class=fndef  id="fndef:1">
    <tr>
        <td class=fndef-backref ><a href="#fnref:1">[1]</a>
        <td class=fndef-content >Per la cronaca, √® il &quot;classico&quot; problema delle stelline e sbarrette.
    
</table>
<table class=fndef  id="fndef:2">
    <tr>
        <td class=fndef-backref ><a href="#fnref:2">[2]</a>
        <td class=fndef-content >Se avete letto il &quot;&#33;&quot; come fattoriale tranquilli, non siete i soli, ormai quando anche in giro leggo <em>&quot;buon compleanno&#33; &#43;20&#33;&quot;</em> lo interpreto istintivamente come un &quot;20 fattoriale&quot;.
    
</table>
</p>
<h3 id="probabilit√†_iniziali"><a href="#probabilit√†_iniziali" class=header-anchor >Probabilit√† iniziali</a></h3>
<p>Una volta definito come modellare gli stati, il prossimo passo consiste nel calcolare le probabilit√† che la configurazione iniziale delle palline nelle ciotole sia esattamente un certo stato piuttosto che un altro. Questo servir√† perch√© per trovare il tempo medio necessario ad entrare nella classe ricorrente \(R\), quella in cui tutte le palline sono riunite nella stessa ciotola e quindi il gioco terminer√†, dovremmo espandere<sup id="fnref:3"><a href="#fndef:3" class=fnref >[3]</a></sup> il calcolo su tutti i possibili stati da cui possiamo partire. Moralmente dobbiamo cio√® pesare i contributi portati da ciascuno stato per la probabilit√† di partire proprio da quello stato:</p>
\[ \mathbb{E}(\text{#passi per entrare in $R$}) =  \sum_{i \in S} \mathbb{E}(\text{#passi per entrare in $R$ partendo da $i$}) \cdot \mathbb{P}(\text{partiamo da $i$})\]
<p>Intuitivamente ha senso: se da uno stato magari ci mettiamo pochi passi per entrare nella classe ricorrente \(R\), ma quella configurazione iniziale √® molto rara da ottenere, allora √® giusto che il suo contributo venga scalato rispetto agli altri.</p>
<p>Comunque, tornando al discorso, per calcolare queste probabilit√† serve invocare la distribuzione Multinomiale, dove diciamo che \({\bf{X}}=(X_1,\ldots,X_n) \sim \text{Mult}(m,(p_1,\ldots,p_n))\) se \({\bf{X}}\) modella lo scenario in cui, ripetendo un certo esperimento aleatorio per \(m\) volte, sono risultate \(X_i\) occorrenze di ciascun evento \(i\), il quale aveva probabilit√† \(p_i\) di verificarsi<sup id="fnref:4"><a href="#fndef:4" class=fnref >[4]</a></sup>.</p>
<p>Questa distribuzione fa precisamente al caso nostro: come \(m\) esperimenti aleatori abbiamo le assegnazioni di ciascuna delle \(m\) palline a una qualunque delle \(n\) ciotole, scelta in modo casuale e con equiprobabilit√†. Quindi tutte le \(p_i\) per \(i=1,\ldots,n\) saranno uguali a \(\frac{1}{n}\). La probabilit√† di ottenere una certa configurazione \(\bf{X}=\bf{x}\) sar√† quindi data dalla densit√† Multinomiale: </p>
\[p_{\bf{X}}({\bf x}) = \mathbb{P}({\bf X}={\bf x}) = \frac{m!}{x_1!\cdots x_n!}\prod_{i=1}^n p_i^{x_i}\]
<p>Questa probabilit√† va per√≤ poi aggiustata contando per le simmetrie. Nel nostro caso, infatti, uno stato del tipo \(00k0\) &#40;rappresentato con la seconda formulazione&#41; sarebbe equivalente a \(k000\), \(0k00\), e \(000k\), dato che sono tutti simmetrici rispetto alla disposizione circolare delle ciotole. L&#39;aggiustamento consiste quindi nel moltiplicare quella probabilit√† &quot;base&quot; per il numero di occorrenze che tale configurazione presenta. Consideriamo ad esempio lo stato \(0002\), dove abbiamo \(n=4\) ciotole e \(m=2\) palline. Questo stato pu√≤ manifestarsi in 4 possibili casi &#40;come appena spiegato, sciogliendo la simmetria circolare&#41;, quindi la probabilit√† di ottenere tala configurazione √® pari a </p>
\[p(0002) = 4\cdot\frac{2!}{0!0!0!2!} \left(\frac{1}{4}\right)^0\left(\frac{1}{4}\right)^0\left(\frac{1}{4}\right)^0 \left(\frac{1}{4}\right)^2 = \frac{1}{4}\]
<p><table class=fndef  id="fndef:3">
    <tr>
        <td class=fndef-backref ><a href="#fnref:3">[3]</a>
        <td class=fndef-content >Tecnicamente, si pu√≤ dire anche esplodere o disintegrare&#33; molto pi√π divertenti.
    
</table>
<table class=fndef  id="fndef:4">
    <tr>
        <td class=fndef-backref ><a href="#fnref:4">[4]</a>
        <td class=fndef-content >Come vincoli, abbiamo da chiedere che \(\sum p_i=1\) &#40;qualcosa deve sempre verificarsi&#41; e \(\sum X_i = m\) &#40;le occorrenze di ciascun evento devono ammontare al totale di esperimenti condotti&#41;.
    
</table>
</p>
<h3 id=finalmente_un_po_di_codice ><a href="#finalmente_un_po_di_codice" class=header-anchor >Finalmente un po&#39; di codice</a></h3>
<p>Le funzioni qui di seguito si occupano di generare le variabili finora introdotte. Di ogni funzione propongo anche alcuni esempietti di esecuzione, con l&#39;opzione <code>verbose</code> attiva, in modo da facilitarne la comprensione.</p>
<pre><code class=language-julia ># generate all possible states of where balls can be located in the bowls
function get_all_states&#40;n::Int, m::Int; verbose&#61;false&#41;
	if n &#61;&#61; 1
		return &#91;&#91;m&#93;&#93;
	end
	ret &#61; &#91;&#93;
	for i in 0:m # loop balls&#39; assignments from 0 to m
		if verbose @show i end
		# fill the n-1 left spots with the remaining m-i balls
		tmp &#61; get_all_states&#40;n-1, m-i, verbose&#61;false&#41;
		for t in tmp
			if verbose println&#40;&quot;\tt&#61;&#36;t&quot;&#41; end
			push&#33;&#40;t, i&#41;
			push&#33;&#40;ret, t&#41;
		end
	end
	return ret
end
get_all_states&#40;3,2,verbose&#61;true&#41;</code></pre><pre><code class="plaintext code-output">i = 0
	t=[2, 0]
	t=[1, 1]
	t=[0, 2]
i = 1
	t=[1, 0]
	t=[0, 1]
i = 2
	t=[0, 0]
6-element Vector{Any}:
 [2, 0, 0]
 [1, 1, 0]
 [0, 2, 0]
 [1, 0, 1]
 [0, 1, 1]
 [0, 0, 2]</code></pre>
<pre><code class=language-julia ># reduce states to their minimal representation, ie accounting for simmetries
function min_state&#40;best::Vector; verbose&#61;false&#41;
    tmp &#61; copy&#40;best&#41;
    rtmp &#61; reverse&#40;copy&#40;best&#41;&#41;
	if verbose @show tmp,rtmp,best end
    for i in 1:length&#40;best&#41;
        tmp &#61; circshift&#40;tmp, 1&#41;
        if tmp &lt; best
            best &#61; copy&#40;tmp&#41;
        end
        rtmp &#61; circshift&#40;rtmp, 1&#41;
        if rtmp &lt; best
            best &#61; copy&#40;rtmp&#41;
        end
		if verbose @show tmp,rtmp,best end
    end
    return best
end
min_state&#40;&#91;1,2,0,0,1&#93;,verbose&#61;true&#41;&#39;</code></pre><pre><code class="plaintext code-output">(tmp, rtmp, best) = ([1, 2, 0, 0, 1], [1, 0, 0, 2, 1], [1, 2, 0, 0, 1])
(tmp, rtmp, best) = ([1, 1, 2, 0, 0], [1, 1, 0, 0, 2], [1, 1, 0, 0, 2])
(tmp, rtmp, best) = ([0, 1, 1, 2, 0], [2, 1, 1, 0, 0], [0, 1, 1, 2, 0])
(tmp, rtmp, best) = ([0, 0, 1, 1, 2], [0, 2, 1, 1, 0], [0, 0, 1, 1, 2])
(tmp, rtmp, best) = ([2, 0, 0, 1, 1], [0, 0, 2, 1, 1], [0, 0, 1, 1, 2])
(tmp, rtmp, best) = ([1, 2, 0, 0, 1], [1, 0, 0, 2, 1], [0, 0, 1, 1, 2])
1√ó5 adjoint(::Vector{Int64}) with eltype Int64:
 0  0  1  1  2</code></pre>
<pre><code class=language-julia ># compute initial probabilities for the states
function get_states&#40;bowls::Int, balls::Int; verbose&#61;false&#41;
	allStates &#61; get_all_states&#40;bowls, balls&#41;
	multiStates &#61; OrderedDict&#123;Vector&#123;Real&#125;,Int&#125;&#40;&#41;
	states &#61; Vector&#123;Vector&#123;Int64&#125;&#125;&#40;&#41;
	for s in allStates
		min_s &#61; min_state&#40;s&#41;
		multiStates&#91;min_s&#93; &#61; get&#40;multiStates, min_s, 0&#41; &#43; 1
		if &#33;&#40;min_s in states&#41;
			push&#33;&#40;states, min_s&#41;
		end
	end
	if verbose
		for &#40;key, val&#41; in multiStates
			println&#40;&quot;stato: &quot;, key, &quot; &#61;&gt; # ocorrenze: &quot;, val&#41;
		end
	end
	prob &#61; factorial&#40;balls&#41; / &#40;bowls ^ balls&#41;
	if verbose
		@show states
		@show prob
	end
	init_probs &#61; Float64&#91;&#93;
	for x in states
		if verbose print&#40;x&#41; end
		p &#61; multiStates&#91;x&#93; * prob
		for y in x
			p *&#61; 1 / factorial&#40;y&#41;
		end
		if verbose print&#40;&quot; -&gt; p: &#36;p&quot;&#41; end
		push&#33;&#40;init_probs, p&#41;
		if verbose println&#40;&#41; end
	end
	return states, init_probs
end
states, probs &#61; get_states&#40;5,3,verbose&#61;true&#41;;</code></pre><pre><code class="plaintext code-output">stato: Real[0, 0, 0, 0, 3] => # ocorrenze: 5
stato: Real[0, 0, 0, 1, 2] => # ocorrenze: 10
stato: Real[0, 0, 1, 0, 2] => # ocorrenze: 10
stato: Real[0, 0, 1, 1, 1] => # ocorrenze: 5
stato: Real[0, 1, 0, 1, 1] => # ocorrenze: 5
states = [[0, 0, 0, 0, 3], [0, 0, 0, 1, 2], [0, 0, 1, 0, 2], [0, 0, 1, 1, 1], [0, 1, 0, 1, 1]]
prob = 0.048
[0, 0, 0, 0, 3] -> p: 0.039999999999999994
[0, 0, 0, 1, 2] -> p: 0.24
[0, 0, 1, 0, 2] -> p: 0.24
[0, 0, 1, 1, 1] -> p: 0.24
[0, 1, 0, 1, 1] -> p: 0.24
</code></pre>
<pre><code class=language-julia ># check if a state is absorbing
function is_absorbing&#40;state::Vector&#41;
	return sum&#40;state .&#61;&#61; 0&#41; &#61;&#61; length&#40;state&#41;-1
end

states, probs &#61; get_states&#40;4,2&#41;
for st in states
	println&#40;st, &quot; -&gt; is_absorbing? &quot;, is_absorbing&#40;st&#41;&#41;
end</code></pre><pre><code class="plaintext code-output">[0, 0, 0, 2] -> is_absorbing? true
[0, 0, 1, 1] -> is_absorbing? false
[0, 1, 0, 1] -> is_absorbing? false
</code></pre>
<p>Ecco quindi un esempietto riassuntivo finale:</p>
<pre><code class=language-julia >begin
	bowls &#61; 4
	balls &#61; 3
	println&#40;&quot;Working with &#36;bowls bowls and &#36;balls balls.&quot;&#41;
	println&#40;&quot;All states and minimal representations:&quot;&#41;
	for v in get_all_states&#40;bowls,balls&#41;
		println&#40;v,&quot; &#61;&gt; &quot;, min_state&#40;v&#41;&#41;
	end
	println&#40;&quot;Initial probabilities:&quot;&#41;
	states, init_probs &#61; get_states&#40;bowls, balls,verbose&#61;false&#41;
	for i in 1:length&#40;states&#41;
		println&#40;states&#91;i&#93;, &quot; &#61;&gt; &quot;, init_probs&#91;i&#93;&#41;
	end
end</code></pre><pre><code class="plaintext code-output">Working with 4 bowls and 3 balls.
All states and minimal representations:
[3, 0, 0, 0] => [0, 0, 0, 3]
[2, 1, 0, 0] => [0, 0, 1, 2]
[1, 2, 0, 0] => [0, 0, 1, 2]
[0, 3, 0, 0] => [0, 0, 0, 3]
[2, 0, 1, 0] => [0, 1, 0, 2]
[1, 1, 1, 0] => [0, 1, 1, 1]
[0, 2, 1, 0] => [0, 0, 1, 2]
[1, 0, 2, 0] => [0, 1, 0, 2]
[0, 1, 2, 0] => [0, 0, 1, 2]
[0, 0, 3, 0] => [0, 0, 0, 3]
[2, 0, 0, 1] => [0, 0, 1, 2]
[1, 1, 0, 1] => [0, 1, 1, 1]
[0, 2, 0, 1] => [0, 1, 0, 2]
[1, 0, 1, 1] => [0, 1, 1, 1]
[0, 1, 1, 1] => [0, 1, 1, 1]
[0, 0, 2, 1] => [0, 0, 1, 2]
[1, 0, 0, 2] => [0, 0, 1, 2]
[0, 1, 0, 2] => [0, 1, 0, 2]
[0, 0, 1, 2] => [0, 0, 1, 2]
[0, 0, 0, 3] => [0, 0, 0, 3]
Initial probabilities:
[0, 0, 0, 3] => 0.0625
[0, 0, 1, 2] => 0.375
[0, 1, 0, 2] => 0.1875
[0, 1, 1, 1] => 0.375
</code></pre>
<h3 id=assembliamo_la_soluzione ><a href="#assembliamo_la_soluzione" class=header-anchor >Assembliamo la soluzione</a></h3>
<p>Ora che disponiamo di alcuni degli elementi fondamentali per modellare il problema, possiamo audacemente proseguire verso il sistema lineare che ci condurr√† effettivamente alla sua soluzione. Dopo aver definito alcune variabili di supporto e di contesto, tra cui in particolare gli stati e il vettore delle probabilit√† iniziali,</p>
<pre><code class=language-julia >nbowls &#61; 4; nballs &#61; 5
# definiamo gli stati e le probabilit√† iniziali
states, p‚ÇÄ &#61; get_states&#40;nbowls, nballs&#41;
# salviamo l&#39;indice di ogni stato, per accederci con 1, 2, ecc nella matrice P
states_dict &#61; Dict&#40;state &#61;&gt; i for &#40;i, state&#41; in enumerate&#40;states&#41;&#41;
nstates &#61; length&#40;states&#41;;</code></pre>
<p>occorre ora costruire la matrice \(P\). Per farlo, l&#39;idea √® che possiamo iterare sugli stati e guardare in quali altri stati possiamo arrivare seguendo i possibili modi in cui le palline possono spostarsi.</p>
<pre><code class=language-julia >P &#61; zeros&#40;nstates, nstates&#41;
for st in states
	if &#33;is_absorbing&#40;st&#41;
		for i in 1:nbowls
			if st&#91;i&#93; &gt; 0
				# where can the current ball move?

				# can move with direction -1
				st_new_m1 &#61; copy&#40;st&#41;
				st_new_m1&#91;i&#93; -&#61; 1; st_new_m1&#91;mod1&#40;i-1,nbowls&#41;&#93; &#43;&#61;1 # move by -1
				st_new_m1 &#61; min_state&#40;st_new_m1&#41; # retrieve minimal configuration
				# or with direction 1
				st_new_p1 &#61; copy&#40;st&#41;
				st_new_p1&#91;i&#93; -&#61; 1; st_new_p1&#91;mod1&#40;i&#43;1,nbowls&#41;&#93; &#43;&#61;1 # move by &#43;1
				st_new_p1 &#61; min_state&#40;st_new_p1&#41; # retrieve minimal configuration

				# update P matrix entries
				P&#91;states_dict&#91;st&#93;,states_dict&#91;st_new_m1&#93;&#93; &#43;&#61; st&#91;i&#93;
				P&#91;states_dict&#91;st&#93;,states_dict&#91;st_new_p1&#93;&#93; &#43;&#61; st&#91;i&#93;
			end
		end
	else
		# if state is absorbing can only go to itself
		P&#91;states_dict&#91;st&#93;,states_dict&#91;st&#93;&#93; &#61; 1
	end
end
# normalize the matrix by dividing each value by the sum of its row values
Int.&#40;P&#41; ## prima</code></pre><pre><code class="plaintext code-output">10√ó10 Matrix{Int64}:
 1  0  0  0  0  0  0  0  0  0
 1  0  4  1  0  0  4  0  0  0
 0  2  3  0  2  3  0  0  0  0
 0  2  0  0  8  0  0  0  0  0
 0  0  1  1  0  3  1  1  0  3
 0  0  1  0  2  1  2  0  2  2
 0  2  0  0  2  6  0  0  0  0
 0  0  0  0  4  0  0  0  6  0
 0  0  0  0  0  4  0  2  0  4
 0  0  0  0  2  2  0  0  2  4</code></pre>
<pre><code class=language-julia >for i in 1:size&#40;P&#41;&#91;1&#93;
	P&#91;i,:&#93; &#61; P&#91;i,:&#93;/sum&#40;P&#91;i,:&#93;&#41;
end
P ## dopo</code></pre><pre><code class="plaintext code-output">10√ó10 Matrix{Float64}:
 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.1  0.0  0.4  0.1  0.0  0.0  0.4  0.0  0.0  0.0
 0.0  0.2  0.3  0.0  0.2  0.3  0.0  0.0  0.0  0.0
 0.0  0.2  0.0  0.0  0.8  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.1  0.1  0.0  0.3  0.1  0.1  0.0  0.3
 0.0  0.0  0.1  0.0  0.2  0.1  0.2  0.0  0.2  0.2
 0.0  0.2  0.0  0.0  0.2  0.6  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.4  0.0  0.0  0.0  0.6  0.0
 0.0  0.0  0.0  0.0  0.0  0.4  0.0  0.2  0.0  0.4
 0.0  0.0  0.0  0.0  0.2  0.2  0.0  0.0  0.2  0.4</code></pre>
<p>Diventa anche molto bello plottare il grafo che mostra le possibili transizioni tra gli stati della catena di Markov, dove giustamente osserviamo che esiste un solo stato assorbente &#40;l&#39;unico ad avere come unica freccia una freccia verso s√© stesso&#41;.</p>
<pre><code class=language-julia ># https://docs.juliaplots.org/stable/generated/graph_attributes/#graph_attributes
graphplot&#40;P,
	names&#61;join.&#40;states&#41;,
	nodesize &#61; 0.2,
	curvature_scalar&#61;0.1,
	node_shape&#61;:circle,
	# edge_label &#61; P,
	# edgelabel_offset &#61; 0,
	fontsize &#61; 4,
	self_edge_size &#61; 0.12,
	method&#61;:circular,
	axis_buffer&#61;0.2&#41;</code></pre>
<img src="/assets/activity/project_euler/problem_930/code/output/mc_graph_real.svg" alt="">
<p>Una volta creata \(P\), dobbiamo capire come usarla per risolvere il problema. Possiamo intanto osservare la struttura di \(P\) &#40;o in generale di una qualunque matrice di transizione per una catena di Markov che presenta stati assorbenti&#41;. La struttura di \(P\) √® infatti </p>
\[ P =\begin{pmatrix} I & O\\ R &  Q\end{pmatrix}\]
<p>dove</p>
<ul>
<li><p>\(I\) √® la matrice identit√†, corrispondente alle transizioni degli stati assorbenti verso s√© stessi</p>

<li><p>\(O\) √® una matrice piena di zeri, perch√© dagli stati assorbenti non ci si pu√≤ spostare a quelli transienti</p>

<li><p>\(Q\) √® la matrice che descrive come da uno stato transiente ci si pu√≤ spostare in un altro transiente</p>

<li><p>\(R\) √® la matrice che descrive come da uno stato transiente ci si pu√≤ spostare in uno assorbente</p>

</ul>
<p>Noto solo ora che non ho mai chiarito cosa si intende precisamente con stati assorbenti o transienti. Forse perch√© supponevo che dal nome fosse tutto sommato intuibile, ma in effetti un po&#39; di teoria anche qui non guasta. Parliamo di stati ricorrenti quando la catena di Markov ci passer√† di sicuro un numero infinito di volte, da cui il nome ricorrenti: continuiamo a visitarli, ne siamo proprio affezionati. Uno stato √® invece transiente se non √® ricorrente, cio√® se quindi,  nel lungo termine, smetteremo di visitarlo. Uno stato assorbente √® la massima espressione di uno stato ricorrente in quanto, una volta entrati in uno stato assorbente, non possiamo pi√π abbandonarlo, ne veniamo infatti &quot;assorbiti&quot;.</p>
<p>Tornando alla struttura di \(P\), con la logica del nostro codice esister√† un solo stato assorbente, e si trover√† sempre in posizione 1. Di conseguenza, gli indici <code>2:end</code> definiranno la matrice \(Q\).</p>
<p>Questa matrice \(Q\) serve, e siamo quasi arrivati alla fine, per risolvere il sistema dei &quot;mean hitting time&quot;. L&#39;obiettivo era infatti di trovare \(k_i^R=\mathbb{E}_i(H_R)\), ovvero il tempo &#40;o equivalentemente, il numero di passi&#41; medio necessario per entrare nella classe \(R\) degli stati ricorrenti, partendo da un qualunque stato \(i\). Nel nostro caso, in realt√†, la classe \(R\) √® formata dall&#39;unico stato assorbente, e quindi ricorrente, in cui le palline sono tutte riunite assieme nella stessa ciotola &#40;in simboli, la configurazione \(00\ldots 00m\)&#41;. Si pu√≤ ricavare che</p>
\[ \begin{cases} k_i^R = 0 & i\in R\\ k_i^R = 1+\sum_{j\notin R}p_{ij}k_j^R & i\notin R \end{cases} \]
<p>Trascurando, in generale, gli stati ricorrenti &#40;nel nostro caso, di nuovo, sarebbe trascurare un solo stato&#41; che non danno contributo, essendo che per loro \(k_i^R=0\), possiamo considerare la sola seconda equazione e vederla in forma vettoriale \({\bf{k}} = {\bf{1}} + Q\bf{k}\), da cui si ricava il sistema \((I-Q)\bf{k} = \bf{1}\), che possiamo risolvere in julia in modo classico con l&#39;operatore backslash <code>\</code>, altrimenti usando metodi pi√π sofisticati dal pacchetto <code>IterativeSolvers</code>.</p>
<pre><code class=language-julia ># https://en.wikipedia.org/wiki/Absorbing_Markov_chain
Q &#61; P&#91;2:end,2:end&#93;
if size&#40;Q&#41;&#91;1&#93; &gt; 1 # c&#39;√® davvero un sistema da risolvere
	k &#61; &#40;I&#40;nstates-1&#41;-Q&#41;\ones&#40;nstates-1&#41; # metodo classico
	# k &#61; bicgstabl&#40;I&#40;nstates-1&#41;-Q, ones&#40;nstates-1&#41;&#41; # biconjugate gradient method, per esempio
else
	k &#61; &#91;1/&#40;I&#40;nstates-1&#41;-Q&#41;&#91;1&#93;&#93;
end</code></pre><pre><code class="plaintext code-output">9-element Vector{Float64}:
 255.00000000000438
 280.83333333333815
 283.33333333333815
 289.1666666666716
 289.16666666667163
 283.33333333333826
 291.6666666666717
 291.6666666666717
 291.6666666666717</code></pre>
<p>Una volta trovato \(\bf{k}\) possiamo combinarlo con il vettore \(\bf{p_0}\) delle probabilit√† iniziali per trovare la soluzione finale. Data la formulazione del problema, infatti, possiamo dire che</p>
\[\mathbb{E}(\text{#passi per entrare in $R$}) = \sum_{i\in S} k_i^R \cdot \mathbb{P}(\text{partire da $i$})={\bf{k}}^T{\bf{p_0}}\]
<p>da cui ricaviamo</p>
<pre><code class=language-julia >slz &#61; dot&#40;k,p‚ÇÄ&#91;2:end&#93;&#41;</code></pre><pre><code class="plaintext code-output">286.45833333333826</code></pre>
<p>che corrisponde alla soluzione esatta 6875/24:</p>
<pre><code class=language-julia >6875/24</code></pre><pre><code class="plaintext code-output">286.4583333333333</code></pre>
<h3 id=tutto_insieme ><a href="#tutto_insieme" class=header-anchor >Tutto insieme</a></h3>
<p>Infine, riuniamo qui all&#39;interno di un&#39;unica funzione ordinata tutti i passaggi finora esposti. Possiamo anche effettuare qualche piccola ottimizzazione, per esempio definendo la matrice \(P\) come sparsa, grazie alle strutture importate con <code>SparseArrays</code>, in modo da potenzialmente diminuire il consumo di memoria, dato che in effetti la matrice \(P\) di transizione sar√† spesso vuota, essendo che non tutti gli stati conducono a tutti gli stati.</p>
<pre><code class=language-julia >function F&#40;nbowls, nballs; verbose&#61;false, plot_graph&#61;false&#41;
	if verbose println&#40;&quot;Deriving states and initial probabilities&quot;&#41; end
	states, p‚ÇÄ &#61; get_states&#40;nbowls, nballs&#41;
	states_dict &#61; Dict&#40;state &#61;&gt; i for &#40;i, state&#41; in enumerate&#40;states&#41;&#41;
	nstates &#61; length&#40;states&#41;
	P &#61; spzeros&#40;nstates, nstates&#41;
	if verbose println&#40;&quot;Assembling transition matrix&quot;&#41; end
	for st in states
		if &#33;is_absorbing&#40;st&#41;
			for i in 1:nbowls
				if st&#91;i&#93; &gt; 0
					# where can the current ball move?
					# can move with direction -1
					st_new_m1 &#61; copy&#40;st&#41;
					st_new_m1&#91;i&#93; -&#61; 1; st_new_m1&#91;mod1&#40;i-1,nbowls&#41;&#93; &#43;&#61;1 # move by -1
					st_new_m1 &#61; min_state&#40;st_new_m1&#41; # retrieve minimal configuration
					# or with direction 1
					st_new_p1 &#61; copy&#40;st&#41;
					st_new_p1&#91;i&#93; -&#61; 1; st_new_p1&#91;mod1&#40;i&#43;1,nbowls&#41;&#93; &#43;&#61;1 # move by &#43;1
					st_new_p1 &#61; min_state&#40;st_new_p1&#41; # retrieve minimal configuration
					# update P matrix entries
					P&#91;states_dict&#91;st&#93;,states_dict&#91;st_new_m1&#93;&#93; &#43;&#61; st&#91;i&#93;
					P&#91;states_dict&#91;st&#93;,states_dict&#91;st_new_p1&#93;&#93; &#43;&#61; st&#91;i&#93;
				end
			end
		else
			P&#91;states_dict&#91;st&#93;,states_dict&#91;st&#93;&#93; &#61; 1
		end
	end
	# normalize the matrix by dividing each value by the sum of its row values
	for i in 1:size&#40;P&#41;&#91;1&#93;
		P&#91;i,:&#93; &#61; P&#91;i,:&#93;/sum&#40;P&#91;i,:&#93;&#41;
	end
	if verbose
		println&#40;&quot;Let&#39;s have a view of the sparsity of P&quot;&#41;
		# with pure text output:
		# show&#40;stdout,&quot;text/plain&quot;,P&#41;
		# SparseArrays._show_with_braille_patterns&#40;stdout, P&#41;
		# with a real plot:
		spy&#40;P&#41;
	end
	if plot_graph
		println&#40;&quot;Plotting MC graph&quot;&#41;
		graphplot&#40;P,
		names&#61;join.&#40;states&#41;,
		nodesize &#61; 0.2,
		curvature_scalar&#61;0.1,
		node_shape&#61;:circle,
		# edge_label &#61; P,
		# edgelabel_offset &#61; 0,
		fontsize &#61; 4,
		self_edge_size &#61; 0.12,
		method&#61;:circular,
		axis_buffer&#61;0.2&#41;
	end
	Q &#61; P&#91;2:end,2:end&#93;
	if verbose println&#40;&quot;Solving the linear system&quot;&#41; end
	if size&#40;Q&#41;&#91;1&#93; &gt; 1
		k &#61; &#40;I&#40;nstates-1&#41;-Q&#41;\ones&#40;nstates-1&#41;
	else
		k &#61; &#91;1/&#40;I&#40;nstates-1&#41;-Q&#41;&#91;1&#93;&#93;
	end
	slz &#61; dot&#40;k,p‚ÇÄ&#91;2:end&#93;&#41;
	if verbose println&#40;&quot;done&#33;&quot;&#41; end
	return slz
end
F&#40;12,6,verbose&#61;true,plot_graph&#61;false&#41;</code></pre><pre><code class="plaintext code-output">Deriving states and initial probabilities
Assembling transition matrix
Let's have a view of the sparsity of P
Solving the linear system
done!
278898.18162320857</code></pre>
<img src="/assets/activity/project_euler/problem_930/code/output/P_sparsity.svg" alt="">
<pre><code class=language-julia >function G&#40;N,M&#41;
	S &#61; 0
	for n in 2:N, m in 2:M
		println&#40;&quot;&#40;n,m&#41;&#61;&#40;&#36;n,&#36;m&#41;&quot;&#41;
		@time S &#43;&#61; F&#40;n,m&#41;
		println&#40;&quot;&quot;&#41;
	end
	println&#40;&quot;done&#33;&quot;&#41;
	return S
end

G&#40;4,5&#41; # giusto un esempio</code></pre><pre><code class="plaintext code-output">(n,m)=(2,2)
  0.000081 seconds (250 allocations: 10.547 KiB)

(n,m)=(2,3)
  0.000061 seconds (281 allocations: 11.656 KiB)

(n,m)=(2,4)
  0.000077 seconds (488 allocations: 34.094 KiB)

(n,m)=(2,5)
  0.000032 seconds (517 allocations: 35.141 KiB)

(n,m)=(3,2)
  0.000020 seconds (395 allocations: 15.875 KiB)

(n,m)=(3,3)
  0.000037 seconds (790 allocations: 45.578 KiB)

(n,m)=(3,4)
  0.000049 seconds (1.07 k allocations: 58.266 KiB)

(n,m)=(3,5)
  0.000107 seconds (1.43 k allocations: 74.391 KiB)

(n,m)=(4,2)
  0.000052 seconds (836 allocations: 51.047 KiB)

(n,m)=(4,3)
  0.000095 seconds (1.43 k allocations: 79.172 KiB)

(n,m)=(4,4)
  0.000182 seconds (2.73 k allocations: 145.625 KiB)

(n,m)=(4,5)
  0.000214 seconds (3.94 k allocations: 211.531 KiB)

done!
523.083333333338</code></pre>
<pre><code class=language-julia >6277/12 # la soluzione esatta per G&#40;4,5&#41;</code></pre><pre><code class="plaintext code-output">523.0833333333334</code></pre>

<script src="https://giscus.app/client.js"
		data-repo="federicomor/federicomor.github.io"
		data-repo-id=R_kgDOLBdBYA 
		data-category=Announcements 
		data-category-id=DIC_kwDOLBdBYM4Clm0M 
		data-mapping=url 
		data-strict=0 
		data-reactions-enabled=1 
		data-emit-metadata=0 
		data-input-position=bottom 
		data-theme=preferred_color_scheme 
		data-lang=it 
		// data-loading=lazy  crossorigin=anonymous 
		async>
</script>

<div class=page-foot >
    
    Last modified: May 16, 2025. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the lovely <a href="https://julialang.org">Julia programming language</a>.
</div>
</div>
    </div>  
    
        <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/contrib/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

<!-- <script>
MathJax = {
	tex: {
	inlineMath: [['\\(', '\\)']],
	tags: 'all'
	},
	svg: {fontCache: 'global'}
};
</script>
<script id=MathJax-script  async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script> -->
    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>