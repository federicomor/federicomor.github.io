<!doctype html> <html lang=en > <a id=top ></a> <link rel=icon  href="/assets/favicon.png"> <link rel=icon  type="image/x-icon" href="/assets/favicon.png"> <link rel=icon  type="image/png" href="/assets/favicon.png"/> <link rel=icon  href="/assets/main img.jpg"> <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { response = await fetch(url); fig = await response.json(); Plotly.newPlot(div, fig); }; </script> <link rel=stylesheet  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_hyde.css"> <link rel=icon  href="/assets/favicon.png"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <title>P930</title> <!-- <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { console.log("url: ",url); console.log("div: ",div); response = await fetch(url); fig = await response.json(); if (typeof fig.config === 'undefined') { fig["config"]={} } delete fig.layout.width delete fig.layout.height fig["layout"]["autosize"] = true fig["config"]["autosizable"] = true fig["config"]["responsive"] = true fig.config["scrollZoom"] = false delete fig.config.staticPlot delete fig.config.displayModeBar delete fig.config.doubleClick delete fig.config.showTips Plotly.newPlot(div, fig); }; </script> --> <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> <script> const PlotlyJS_json = async (div, url) => { response = await fetch(url); fig = await response.json(); Plotly.newPlot(div, fig); }; </script> <!-- <a class=backToTopBtn  title="back to top // torna in cima" href="#top"> <span class=backToTopBtn-icon >^</span> </a> --> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <!-- <h1><a href="/">Hyde</a></h1> <p class=lead >A two-column theme.</p> --> <h1><a href="/">Eccoci.<img style="display: block; margin: 0 auto; margin-bottom: 20px"; width=170 ; src="/assets/main img.jpg" alt="main img"/></a></h1> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/">Home</a> <a class="sidebar-nav-item " href="/activity/">Attivit√†</a> <a class="sidebar-nav-item " href="/uni/">Uni</a> <a class="sidebar-nav-item " href="/portfolio/">Portfolio</a> </nav> <a href="https://www.youtube.com/channel/UC1_68R2Kv1htcZ1It5il7CQ" target=_blank rel=noopener> <i class="fab fa-youtube big-icon"></i></a> <a href="https://www.linkedin.com/in/federico-angelo-mor/" target=_blank rel=noopener> <i class="fab fa-linkedin big-icon"></i></a> <a href="https://github.com/federicomor" target=_blank rel=noopener> <i class="fab fa-github big-icon"></i></a> </div> </div> <div class="content container"> <a class=backToTopBtn  title="back to top // torna in cima" href="#top"> <span class=backToTopBtn-icon >‚àß</span> </a> <div class=franklin-content > <div class=navigation_symbols > <form action="" method=get  onsubmit="location.href='/activity/project_euler/problem_' + this.elements[0].value; return false;" style="display:inline;"> <input title="go to problem" type="" placeholder=" " required style="margin-right: 5px; width: 40px; padding: 3px; text-align: center; border: 1px solid #666666; border-radius: 4px;"> </form> <a href="/activity/project_euler/problem_929/" style="color: black; text-decoration: none;"><i class="fa-solid fa-arrow-left"></i></a> <a href="/activity/project_euler" style="color: black; text-decoration: none;">üè† </a> <a href="/activity/project_euler/problem_931/" style="color: black; text-decoration: none;"><i class="fa-solid fa-arrow-right"></i></a> </div> <link rel=stylesheet  type="text/css" href="/activity/project_euler/style_main.1735430422.css"> <link rel=stylesheet  type="text/css" href="/activity/project_euler/style_default.1627113674.css"> <script src="https://projecteuler.net/js/mathjax_config.js"></script> <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?version=4.8.0&features=es6"></script> <script id=MathJax-script  async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script> <div id=content > <div class="center print"><img src="https://projecteuler.net/images/clipart/print_page_logo.png" alt=projecteuler.net ></div> <h2>The Gathering</h2><div id=problem_icons  class=noprint ><span class=tooltip >‚ÑπÔ∏è<span class=tooltiptext_right >Published on Sunday, 2nd February 2025, 10:00 am; Solved by 97</span></span></div><div id=problem_info ><h3><a href="https://projecteuler.net/problem=930">Problem 930</a></h3></div> <div class=problem_content  role=problem > <p>Given $n\ge 2$ bowls arranged in a circle, $m\ge 2$ balls are distributed amongst them.</p> <p>Initially the balls are distributed randomly: for each ball, a bowl is chosen equiprobably and independently of the other balls. After this is done, we start the following process:</p> <ol> <li>Choose one of the $m$ balls equiprobably at random. <li>Choose a direction to move - either clockwise or anticlockwise - again equiprobably at random. <li>Move the chosen ball to the neighbouring bowl in the chosen direction. <li>Return to step 1. </ol> <p>This process stops when all the $m$ balls are located in the same bowl. Note that this may be after zero steps, if the balls happen to have been initially distributed all in the same bowl.</p> <p>Let $F(n, m)$ be the expected number of times we move a ball before the process stops. For example, $F(2, 2) = \frac{1}{2}$, $F(3, 2) = \frac{4}{3}$, $F(2, 3) = \frac{9}{4}$, and $F(4, 5) = \frac{6875}{24}$.</p> <p>Let $G(N, M) = \sum_{n=2}^N \sum_{m=2}^M F(n, m)$. For example, $G(3, 3) = \frac{137}{12}$ and $G(4, 5) = \frac{6277}{12}$. You are also given that $G(6, 6) \approx 1.681521567954e4$ in scientific format with 12 significant digits after the decimal point.</p> <p>Find $G(12, 12)$. Give your answer in scientific format with 12 significant digits after the decimal point.</p> </div><br> <br> </div> <!--end_content--> <h2 id=soluzione ><a href="#soluzione" class=header-anchor >Soluzione</a></h2> <p>Partiamo caricando tutti gli strumentopoli miseteriosi necessari alla soluzione.</p> <pre><code class=language-julia >using Random, LinearAlgebra
using SparseArrays
using DataStructures
using IterativeSolvers
using Plots, GraphRecipes
Random.seed&#33;&#40;29032025&#41;;</code></pre> <p>Per iniziare ad ambientarci nel contesto del problema, ovvero con il meccanismo di spostamento delle palline nelle ciotole, la condizione di terminazione del gioco, ecc, possiamo implementare una semplice simulazione del gioco stesso, osservando quali possibili scenari possono verificarsi.</p> <pre><code class=language-julia >######### SIMULATED EXECUTION #########
# n bowls, m balls
function simulate_F&#40;n::Int, m::Int; num_trials::Int&#61;10000, verbose&#61;false&#41;
    total_moves &#61; 0
	if verbose num_trials &#61; 1 end

    for _ in 1:num_trials
        # random initial distribution of balls
        balls &#61; rand&#40;1:n, m&#41; # array of size m, each element in 1:n
        # so that each ball i is assigned to the bowl given by balls&#91;i&#93;
        moves &#61; 0

        while length&#40;unique&#40;balls&#41;&#41; &gt; 1 # stop when all balls are in the same bowl
        # and they will be in the same bowl when all the indexes of balls vector will be equal
            ball_idx &#61; rand&#40;1:m&#41; # pick a ball at random
            direction &#61; rand&#40;&#91;-1, 1&#93;&#41; # pick a direction &#40;-1 for counterclockwise, 1 for clockwise&#41;
			if verbose println&#40;&quot;Balls are in bowls: &#36;balls &#40;selected ball: &#36;ball_idx, will move by: &#36;direction&#41;&quot;&#41; end
            balls&#91;ball_idx&#93; &#61; mod1&#40;balls&#91;ball_idx&#93; &#43; direction, n&#41; # move the ball
            # this changes the bowl attribution of ball ball_idx, using mod1 as for the circular structure
            moves &#43;&#61; 1
        end
		total_moves &#43;&#61; moves
		if verbose
			println&#40;&quot;Balls are in bowls: &#36;balls&quot;&#41;
			println&#40;&quot;Total moves: &#36;total_moves&quot;&#41;
		end
    end
    return total_moves / num_trials  # estimate of F&#40;n, m&#41;
end</code></pre><pre><code class="plaintext code-output">simulate_F (generic function with 1 method)</code></pre>
<p>Con cui possiamo o simulare seriamente il problema per ottenere una stima accurata:</p>
<pre><code class=language-julia >simulate_F&#40;2, 3, num_trials &#61; 10_000&#41; # soluzione esatta: 9/4 &#61; 2.25</code></pre><pre><code class="plaintext code-output">2.2151</code></pre>
<p>o altrimenti vedere in concreto cosa accade in un&#39;esempio di esecuzione:</p>
<pre><code class=language-julia >simulate_F&#40;2, 3, verbose&#61;true&#41;</code></pre><pre><code class="plaintext code-output">Balls are in bowls: [2, 1, 2] (selected ball: 3, will move by: -1)
Balls are in bowls: [2, 1, 1] (selected ball: 2, will move by: 1)
Balls are in bowls: [2, 2, 1] (selected ball: 2, will move by: 1)
Balls are in bowls: [2, 1, 1] (selected ball: 1, will move by: -1)
Balls are in bowls: [1, 1, 1]
Total moves: 4
4.0</code></pre>
<p>Ma ovviamente questo non ci basta: vogliamo risolvere il problema in modo esatto. Per farlo, l&#39;idea √® di affidarci alle catene di Markov. Le catene di Markov hanno infatti come principale scopo nella vita quello di poter modellare un contesto stocastico e dinamico, che √® precisamente quello che abbiamo qui: palline disposte inizalmente in modo casuale, che si muovono nelle ciotole sempre seguendo mosse randomiche &#40;riprendo le regole, ad ogni turno una palline viene scelta in modo casuale e si sposta di una ciotola o in senso orario o in senso antiorario&#41;.</p>
<p>Una catena di Markov √® caretterizzata da due elementi: lo spazio degli stati \(S\), ovvero le configurazioni che pu√≤ assumere il sistema che stiamo modellando, e la matrice di transizione \(P\), le cui componenti \(p_{ij}\) descrivono la probabilit√† che da un certo stato \(i\) ci posiamo spostare in un certo stato \(j\).</p>
<h3 id=stati ><a href="#stati" class=header-anchor >Stati</a></h3>
<p>In questo problema, una scelta interessante consiste gi√† nel capire come modellare gli stati. Esistono infatti diversi possibili approccci:</p>
<ol>
<li><p>assegnare a ogni pallina un&#39;etichetta corrispondente alla ciotola in cui √® contenuta</p>

<li><p>assegnare ad ogni ciotola quante palline contiene, pensando alle ciotole come disposte in una fila &#40;quindi esiste la &quot;prima&quot; ciotola, la &quot;seconda&quot; ciotola, ecc&#41; ma mantenendo la configurazione originale del cerchio &#40;quindi dalla ciotola uno possiamo &quot;andare a sinistra&quot; ed entrare nell&#39;ultima ciotola, per intenderci&#41;</p>

<li><p>assegnare ad ogni ciotola quante palline contiene, pensando alle ciotole come disposte nel cerchio, quindi contando le simmetrie delle configurazioni derivate dal metodo del punto 2</p>

</ol>
<p>Avendo \(n\) ciotole ed \(m\) palline, ogni caso prevederebbe una diversa numerosit√† dello spazio degli stati:</p>
<ol>
<li><p>con questa prima formulazione, avremmo che ogni pallina pu√≤ andare in ciascuna ciotola, quindi avremmo \(n\) opzioni per ciascuna delle \(m\) palline, da cui \(n^m\) stati</p>

<li><p>con questa seconda formulazione, avremmo che ogni ciotola, disposta in fila, pu√≤ accogliere da zero a \(m\) palline. Pensando di rappresentare ogni pallina come, beh, una pallina, ed ogni ciotola come una barra &quot;|&quot; &#40;in modo che le palline alla sua destra corrispondano a quelle che lei contiene&#41;, segue che gli stati totali sono i modi in cui possiamo anagrammare la stringa formata da \(m\) palline e \(n-1\) ciotole &#40;meno uno perch√© fissiamo una certa ciotola essere la prima lettera della stringa&#41;. Per la cronaca, √® il &quot;classico&quot; problema delle stelline e sbarrette. Quindi qui il numero di stati diventa </p>

</ol>
\[\frac{(m+n-1)!}{m!(n-1)!}={ m+n-1 \choose m}\]
<ol start=3 >
<li><p>con questa terza formulazione, pi√π complicata perch√© contiamo come una sola configurazione, per via delle simmetrie, configurazioni precedentemente diverse, il numero degli stati diminuisce ulteriormente. Per sapere di quanto diminuisce, beh, di certo esister√† una formula che, come nei casi precedenti, conti elegantemente gli stati in funzione di \(n\) ed \(m\), tuttavia stavolta non ci ho badato troppo: la mia natura ingegneristica ha preso il sopravvento e ho quindi beatamente proseguito col resto del problema</p>

</ol>
<p>Il punto √® infatti che all&#39;aumentare del numero di ciotole e palline, il terzo metodo permette di limitare la numerosit√† degli stati, mantenendo quindi il problema pi√π agilmente risolvibile per un computer. Per esempio, con 12 ciotole e 6 palline, il primo metodo prevederebbe \(12^6=2985984\) stati, il secondo \({17 \choose 6}=12376\), il terzo 561. E siccome in seguito vedremo che ci sar√† da risolvere un sistema, meglio avere sistemi con 561 variabili rispetto a 2985984&#33;</p>
<h3 id="probabilit√†_iniziali"><a href="#probabilit√†_iniziali" class=header-anchor >Probabilit√† iniziali</a></h3>
<p>Una volta definito come modellare gli stati, il prossimo passo consiste nel calcolare le probabilit√† che la configurazione iniziale delle palline nelle ciotole sia esattamente un certo stato piuttosto che un altro. Questo servir√† perch√© per trovare il tempo medio necessario ad entrare nella classe ricorrente dovremmo espandere &#40;tecnicamente, si pu√≤ dire anche esplodere o disintegrare&#33; molto pi√π divertenti&#41; il calcolo su tutti i possibili stati da cui possiamo partire. Ovvero, moralmente dobbiamo pesare i contributi portati da ciascuno stato per la probabilit√† di partire in effetti da quello stato:</p>
\[ \mathbb{E}(\text{#passi per entrare in $R$}) =  \sum_{i \in S} \mathbb{E}(\text{#passi per entrare in $R$ partendo da $i$}) \cdot \mathbb{P}(\text{partiamo da $i$})\]
<p>Intuitivamente ha senso: se da uno stato magari ci mettiamo pochi passi per entrare nella classe ricorrente \(R\), ma quella configurazione iniziale √® molto rara da ottenere, allora √® giusto che il suo contributo venga scalato rispetto agli altri.</p>
<p>Comunque, tornando al discorso, per calcolare queste probabilit√† serve invocare la distribuzione Multinomiale, dove diciamo che \({\bf{X}}=(X_1,\ldots,X_n) \sim \text{Mult}(m,(p_1,\ldots,p_n))\) se \({\bf{X}}\) modella lo scenario in cui, ripetendo un certo esperimento aleatorio per \(m\) volte, sono risultate \(X_i\) occorrenze di ciascun evento \(i\), il quale aveva probabilit√† \(p_i\) di verificarsi. Come vincoli, abbiamo quindi da chiedere che \(\sum p_i=1\) &#40;qualcosa deve sempre verificarsi&#41; e \(\sum X_i = m\) &#40;le occorrenze di ciascun evento ammontano al totale di esperimenti condotti&#41;.</p>
<h3 id=finalmente_un_po_di_codice ><a href="#finalmente_un_po_di_codice" class=header-anchor >Finalmente un po&#39; di codice</a></h3>
<p>Le funzioni qui di seguito si occupano quindi di generare gli stati per la catena di Markov, di cui ne propongo alcuni esempietti di esecuzione con l&#39;opzione <code>verbose</code> attiva, in modo da facilitarne la comprensione.</p>
<pre><code class=language-julia ># generate all possible states of where balls can be located in the bowls
function get_all_states&#40;m::Int, n::Int; verbose&#61;false&#41;
	if m &#61;&#61; 1
		return &#91;&#91;n&#93;&#93;
	end
	ret &#61; &#91;&#93;
	for i in 0:n
		if verbose @show i end
		tmp &#61; get_all_states&#40;m - 1, n - i, verbose&#61;false&#41;
		for t in tmp
			if verbose println&#40;&quot;\tt&#61;&#36;t&quot;&#41; end
			push&#33;&#40;t, i&#41;
			push&#33;&#40;ret, t&#41;
		end
	end
	return ret
end
get_all_states&#40;3,2,verbose&#61;true&#41;</code></pre><pre><code class="plaintext code-output">i = 0
	t=[2, 0]
	t=[1, 1]
	t=[0, 2]
i = 1
	t=[1, 0]
	t=[0, 1]
i = 2
	t=[0, 0]
6-element Vector{Any}:
 [2, 0, 0]
 [1, 1, 0]
 [0, 2, 0]
 [1, 0, 1]
 [0, 1, 1]
 [0, 0, 2]</code></pre>
<pre><code class=language-julia ># reduce states to their minimal representation, ie accounting for simmetries
function min_state&#40;best::Vector; verbose&#61;false&#41;
    tmp &#61; copy&#40;best&#41;
    rtmp &#61; reverse&#40;copy&#40;best&#41;&#41;
	if verbose @show tmp,rtmp,best end
    for i in 1:length&#40;best&#41;
        tmp &#61; circshift&#40;tmp, 1&#41;
        if tmp &lt; best
            best &#61; copy&#40;tmp&#41;
        end
        rtmp &#61; circshift&#40;rtmp, 1&#41;
        if rtmp &lt; best
            best &#61; copy&#40;rtmp&#41;
        end
		if verbose @show tmp,rtmp,best end
    end
    return best
end
min_state&#40;&#91;1,2,0,0,1&#93;,verbose&#61;true&#41;&#39;</code></pre><pre><code class="plaintext code-output">(tmp, rtmp, best) = ([1, 2, 0, 0, 1], [1, 0, 0, 2, 1], [1, 2, 0, 0, 1])
(tmp, rtmp, best) = ([1, 1, 2, 0, 0], [1, 1, 0, 0, 2], [1, 1, 0, 0, 2])
(tmp, rtmp, best) = ([0, 1, 1, 2, 0], [2, 1, 1, 0, 0], [0, 1, 1, 2, 0])
(tmp, rtmp, best) = ([0, 0, 1, 1, 2], [0, 2, 1, 1, 0], [0, 0, 1, 1, 2])
(tmp, rtmp, best) = ([2, 0, 0, 1, 1], [0, 0, 2, 1, 1], [0, 0, 1, 1, 2])
(tmp, rtmp, best) = ([1, 2, 0, 0, 1], [1, 0, 0, 2, 1], [0, 0, 1, 1, 2])
1√ó5 adjoint(::Vector{Int64}) with eltype Int64:
 0  0  1  1  2</code></pre>
<pre><code class=language-julia ># compute initial probabilities for the states
function get_states&#40;bowls::Int, balls::Int; verbose&#61;false&#41;
	allStates &#61; get_all_states&#40;bowls, balls&#41;
	multiStates &#61; OrderedDict&#123;Vector&#123;Real&#125;,Int&#125;&#40;&#41;
	states &#61; Vector&#123;Vector&#123;Int64&#125;&#125;&#40;&#41;
	for s in allStates
		min_s &#61; min_state&#40;s&#41;
		multiStates&#91;min_s&#93; &#61; get&#40;multiStates, min_s, 0&#41; &#43; 1
		if &#33;&#40;min_s in states&#41;
			push&#33;&#40;states, min_s&#41;
		end
		if verbose @show multiStates end
	end
	prob &#61; factorial&#40;balls&#41; / &#40;bowls ^ balls&#41;
	if verbose
		@show states
		@show prob
	end
	init_probs &#61; Float64&#91;&#93;
	for x in states
		if verbose print&#40;x&#41; end
		p &#61; multiStates&#91;x&#93; * prob
		for y in x
			p *&#61; 1 / factorial&#40;y&#41;
		end
		if verbose print&#40;&quot; -&gt; p: &#36;p&quot;&#41; end
		push&#33;&#40;init_probs, p&#41;
		if verbose println&#40;&#41; end
	end
	return states, init_probs
end
states, probs &#61; get_states&#40;5,2,verbose&#61;true&#41;;</code></pre><pre><code class="plaintext code-output">multiStates = OrderedCollections.OrderedDict{Vector{Real}, Int64}([0, 0, 0, 0, 2] => 1)
multiStates = OrderedCollections.OrderedDict{Vector{Real}, Int64}([0, 0, 0, 0, 2] => 1, [0, 0, 0, 1, 1] => 1)
multiStates = OrderedCollections.OrderedDict{Vector{Real}, Int64}([0, 0, 0, 0, 2] => 2, [0, 0, 0, 1, 1] => 1)
multiStates = OrderedCollections.OrderedDict{Vector{Real}, Int64}([0, 0, 0, 0, 2] => 2, [0, 0, 0, 1, 1] => 1, [0, 0, 1, 0, 1] => 1)
multiStates = OrderedCollections.OrderedDict{Vector{Real}, Int64}([0, 0, 0, 0, 2] => 2, [0, 0, 0, 1, 1] => 2, [0, 0, 1, 0, 1] => 1)
multiStates = OrderedCollections.OrderedDict{Vector{Real}, Int64}([0, 0, 0, 0, 2] => 3, [0, 0, 0, 1, 1] => 2, [0, 0, 1, 0, 1] => 1)
multiStates = OrderedCollections.OrderedDict{Vector{Real}, Int64}([0, 0, 0, 0, 2] => 3, [0, 0, 0, 1, 1] => 2, [0, 0, 1, 0, 1] => 2)
multiStates = OrderedCollections.OrderedDict{Vector{Real}, Int64}([0, 0, 0, 0, 2] => 3, [0, 0, 0, 1, 1] => 2, [0, 0, 1, 0, 1] => 3)
multiStates = OrderedCollections.OrderedDict{Vector{Real}, Int64}([0, 0, 0, 0, 2] => 3, [0, 0, 0, 1, 1] => 3, [0, 0, 1, 0, 1] => 3)
multiStates = OrderedCollections.OrderedDict{Vector{Real}, Int64}([0, 0, 0, 0, 2] => 4, [0, 0, 0, 1, 1] => 3, [0, 0, 1, 0, 1] => 3)
multiStates = OrderedCollections.OrderedDict{Vector{Real}, Int64}([0, 0, 0, 0, 2] => 4, [0, 0, 0, 1, 1] => 4, [0, 0, 1, 0, 1] => 3)
multiStates = OrderedCollections.OrderedDict{Vector{Real}, Int64}([0, 0, 0, 0, 2] => 4, [0, 0, 0, 1, 1] => 4, [0, 0, 1, 0, 1] => 4)
multiStates = OrderedCollections.OrderedDict{Vector{Real}, Int64}([0, 0, 0, 0, 2] => 4, [0, 0, 0, 1, 1] => 4, [0, 0, 1, 0, 1] => 5)
multiStates = OrderedCollections.OrderedDict{Vector{Real}, Int64}([0, 0, 0, 0, 2] => 4, [0, 0, 0, 1, 1] => 5, [0, 0, 1, 0, 1] => 5)
multiStates = OrderedCollections.OrderedDict{Vector{Real}, Int64}([0, 0, 0, 0, 2] => 5, [0, 0, 0, 1, 1] => 5, [0, 0, 1, 0, 1] => 5)
states = [[0, 0, 0, 0, 2], [0, 0, 0, 1, 1], [0, 0, 1, 0, 1]]
prob = 0.08
[0, 0, 0, 0, 2] -> p: 0.2
[0, 0, 0, 1, 1] -> p: 0.4
[0, 0, 1, 0, 1] -> p: 0.4
</code></pre>
<pre><code class=language-julia ># check if a state is absorbing
function is_absorbing&#40;state::Vector&#41;
	return sum&#40;state .&#61;&#61; 0&#41; &#61;&#61; length&#40;state&#41;-1
end

states, probs &#61; get_states&#40;4,2&#41;
for st in states
	println&#40;st, &quot; -&gt; is_absorbing? &quot;, is_absorbing&#40;st&#41;&#41;
end</code></pre><pre><code class="plaintext code-output">[0, 0, 0, 2] -> is_absorbing? true
[0, 0, 1, 1] -> is_absorbing? false
[0, 1, 0, 1] -> is_absorbing? false
</code></pre>
<p>Ecco quindi un esempietto riassuntivo finale:</p>
<pre><code class=language-julia >begin
	bowls &#61; 4
	balls &#61; 3
	println&#40;&quot;Working with &#36;bowls bowls and &#36;balls balls.&quot;&#41;
	println&#40;&quot;All states and minimal representations:&quot;&#41;
	for v in get_all_states&#40;bowls,balls&#41;
		println&#40;v,&quot; &#61;&gt; &quot;, min_state&#40;v&#41;&#41;
	end
	println&#40;&quot;Initial probabilities:&quot;&#41;
	states, init_probs &#61; get_states&#40;bowls, balls,verbose&#61;false&#41;
	for i in 1:length&#40;states&#41;
		println&#40;states&#91;i&#93;, &quot; &#61;&gt; &quot;, init_probs&#91;i&#93;&#41;
	end
end</code></pre><pre><code class="plaintext code-output">Working with 4 bowls and 3 balls.
All states and minimal representations:
[3, 0, 0, 0] => [0, 0, 0, 3]
[2, 1, 0, 0] => [0, 0, 1, 2]
[1, 2, 0, 0] => [0, 0, 1, 2]
[0, 3, 0, 0] => [0, 0, 0, 3]
[2, 0, 1, 0] => [0, 1, 0, 2]
[1, 1, 1, 0] => [0, 1, 1, 1]
[0, 2, 1, 0] => [0, 0, 1, 2]
[1, 0, 2, 0] => [0, 1, 0, 2]
[0, 1, 2, 0] => [0, 0, 1, 2]
[0, 0, 3, 0] => [0, 0, 0, 3]
[2, 0, 0, 1] => [0, 0, 1, 2]
[1, 1, 0, 1] => [0, 1, 1, 1]
[0, 2, 0, 1] => [0, 1, 0, 2]
[1, 0, 1, 1] => [0, 1, 1, 1]
[0, 1, 1, 1] => [0, 1, 1, 1]
[0, 0, 2, 1] => [0, 0, 1, 2]
[1, 0, 0, 2] => [0, 0, 1, 2]
[0, 1, 0, 2] => [0, 1, 0, 2]
[0, 0, 1, 2] => [0, 0, 1, 2]
[0, 0, 0, 3] => [0, 0, 0, 3]
Initial probabilities:
[0, 0, 0, 3] => 0.0625
[0, 0, 1, 2] => 0.375
[0, 1, 0, 2] => 0.1875
[0, 1, 1, 1] => 0.375
</code></pre>
<h3 id=assembliamo_la_soluzione ><a href="#assembliamo_la_soluzione" class=header-anchor >Assembliamo la soluzione</a></h3>
<p>Finalmente arriviamo alla fase finale della soluzione</p>
<pre><code class=language-julia >######### ACTUAL SOLVER #########
#&#61; Steps:
1. enumerate the states, maybe divide between transient and recurrent/absorbing
2. build the transition matrix by counting the possible moves from each state, and then normalizing
3. solve the system for the absorbing time
4. print the answer
&#61;#

nbowls &#61; 4; nballs &#61; 5
# definiamo gli stati e le probabilit√† iniziali
states, p‚ÇÄ &#61; get_states&#40;nbowls, nballs&#41;
# salviamo l&#39;indice di ogni stato, per accederci con 1, 2, ecc nella matrice P
states_dict &#61; Dict&#40;state &#61;&gt; i for &#40;i, state&#41; in enumerate&#40;states&#41;&#41;
nstates &#61; length&#40;states&#41;

# definiamo e popoliamo P
P &#61; zeros&#40;nstates, nstates&#41;
for st in states
	if &#33;is_absorbing&#40;st&#41;
		for i in 1:nbowls
			if st&#91;i&#93; &gt; 0
				# where can the current ball move?

				# can move with direction -1
				st_new_m1 &#61; copy&#40;st&#41;
				st_new_m1&#91;i&#93; -&#61; 1; st_new_m1&#91;mod1&#40;i-1,nbowls&#41;&#93; &#43;&#61;1 # move by -1
				st_new_m1 &#61; min_state&#40;st_new_m1&#41; # retrieve minimal configuration
				# or with direction 1
				st_new_p1 &#61; copy&#40;st&#41;
				st_new_p1&#91;i&#93; -&#61; 1; st_new_p1&#91;mod1&#40;i&#43;1,nbowls&#41;&#93; &#43;&#61;1 # move by &#43;1
				st_new_p1 &#61; min_state&#40;st_new_p1&#41; # retrieve minimal configuration

				# update P matrix entries
				P&#91;states_dict&#91;st&#93;,states_dict&#91;st_new_m1&#93;&#93; &#43;&#61; st&#91;i&#93;
				P&#91;states_dict&#91;st&#93;,states_dict&#91;st_new_p1&#93;&#93; &#43;&#61; st&#91;i&#93;
			end
		end
	else
		P&#91;states_dict&#91;st&#93;,states_dict&#91;st&#93;&#93; &#61; 1
	end
end
# normalize the matrix by dividing each value by the sum of its row values
P</code></pre><pre><code class="plaintext code-output">10√ó10 Matrix{Float64}:
 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 1.0  0.0  4.0  1.0  0.0  0.0  4.0  0.0  0.0  0.0
 0.0  2.0  3.0  0.0  2.0  3.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  8.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  1.0  1.0  0.0  3.0  1.0  1.0  0.0  3.0
 0.0  0.0  1.0  0.0  2.0  1.0  2.0  0.0  2.0  2.0
 0.0  2.0  0.0  0.0  2.0  6.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  4.0  0.0  0.0  0.0  6.0  0.0
 0.0  0.0  0.0  0.0  0.0  4.0  0.0  2.0  0.0  4.0
 0.0  0.0  0.0  0.0  2.0  2.0  0.0  0.0  2.0  4.0</code></pre>
<pre><code class=language-julia >for i in 1:size&#40;P&#41;&#91;1&#93;
	P&#91;i,:&#93; &#61; P&#91;i,:&#93;/sum&#40;P&#91;i,:&#93;&#41;
end
P</code></pre><pre><code class="plaintext code-output">10√ó10 Matrix{Float64}:
 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.1  0.0  0.4  0.1  0.0  0.0  0.4  0.0  0.0  0.0
 0.0  0.2  0.3  0.0  0.2  0.3  0.0  0.0  0.0  0.0
 0.0  0.2  0.0  0.0  0.8  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.1  0.1  0.0  0.3  0.1  0.1  0.0  0.3
 0.0  0.0  0.1  0.0  0.2  0.1  0.2  0.0  0.2  0.2
 0.0  0.2  0.0  0.0  0.2  0.6  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.4  0.0  0.0  0.0  0.6  0.0
 0.0  0.0  0.0  0.0  0.0  0.4  0.0  0.2  0.0  0.4
 0.0  0.0  0.0  0.0  0.2  0.2  0.0  0.0  0.2  0.4</code></pre>
<pre><code class=language-julia ># https://docs.juliaplots.org/stable/generated/graph_attributes/#graph_attributes
graphplot&#40;P,
	names&#61;join.&#40;states&#41;,
	nodesize &#61; 0.2,
	curvature_scalar&#61;0.1,
	node_shape&#61;:circle,
	# edge_label &#61; P,
	# edgelabel_offset &#61; 0,
	fontsize &#61; 4,
	self_edge_size &#61; 0.12,
	method&#61;:circular,
	axis_buffer&#61;0.2&#41;</code></pre>
<img src="/assets/activity/project_euler/problem_930/code/output/mc_graph_.svg" alt="">
<pre><code class=language-julia ># https://en.wikipedia.org/wiki/Absorbing_Markov_chain</code></pre>
<p>La struttura di \(P\) √® \(P = [I \,\,O; R\,\, Q]\) dove</p>
<ul>
<li><p>\(I\) √® la matrice identit√†, corrispondente alle transizioni degli stati assorbenti verso s√© stessi</p>

<li><p>\(O\) √® una matrice piena di zeri perch√© dagli stati assorbenti non si pu√≤ spostarsi a quelli transienti</p>

<li><p>\(Q\) √® la matrice che descrive come da uno stato transiente ci si pu√≤ spostare in un altro transiente</p>

<li><p>\(R\) √® la matrice che descrive come da uno stato transiente ci si pu√≤ spostare in uno assorbente</p>

</ul>
<p>Con la logica di questo codice, ovvero con questa rappresentazione minimale degli stati, esister√† un solo stato assorbente, e si trover√† in posizione 1. Di conseguenza, gli indici <code>2:end</code> definiranno la matrice Q.</p>
<p>Questa matrice Q serve per risolvere il sistema dei &quot;mean hitting time&quot;. L&#39;obiettivo √® infatti di trovare \(k_i^R=\mathbb{E}_i(H_R)\), ovvero il tempo &#40;o equivalentemente, il numero di passi&#41; medio necessario per entrare nella classe \(R\) degli stati ricorrenti, partendo da un qualunque stato \(i\). Si pu√≤ ricavare che</p>
\[ \begin{cases} k_i^R = 0 & i\in R\\ k_i^R = 1+\sum_{j\notin R}p_{ij}k_j^R & i\notin R \end{cases} \]
<p>Trascurando gli stati ricorrenti che non danno contributo &#40;essendo che per loro \(k_i^R=0\)&#41; possiamo considerare la sola seconda equazione e vederla in forma vettoriale \({\bf{k}} = {\bf{1}} + Q\bf{k}\), da cui si ricava il sistema \((I-Q)\bf{k} = \bf{1}\). Questo possiamo risolverlo in modo classico in julia con l&#39;operatore backslash <code>\</code>, altrimenti usando metodi pi√π sofisticati dal pacchetto <code>IterativeSolvers</code>.</p>
<pre><code class=language-julia >Q &#61; P&#91;2:end,2:end&#93;
if size&#40;Q&#41;&#91;1&#93; &gt; 1 # c&#39;√® davvero un sistema da risolvere
	k &#61; &#40;I&#40;nstates-1&#41;-Q&#41;\ones&#40;nstates-1&#41; # metodo classico
	# k &#61; bicgstabl&#40;I&#40;nstates-1&#41;-Q, ones&#40;nstates-1&#41;&#41; # biconjugate gradient method
else
	k &#61; &#91;1/&#40;I&#40;nstates-1&#41;-Q&#41;&#91;1&#93;&#93;
end</code></pre><pre><code class="plaintext code-output">9-element Vector{Float64}:
 255.00000000000438
 280.83333333333815
 283.33333333333815
 289.1666666666716
 289.16666666667163
 283.33333333333826
 291.6666666666717
 291.6666666666717
 291.6666666666717</code></pre>
<p>e una volta trovato \(\bf{k}\) possiamo combinarlo con il vettore \(\bf{p_0}\) delle probabilit√† iniziali per trovare la soluzione finale. Data la formulazione del problema, infatti, possiamo dire che</p>
\[\mathbb{E}(\text{#passi per entrare in $R$}) = \sum_i k_i^R \cdot \mathbb{P}(\text{partire da $i$})={\bf{k}}^T{\bf{p_0}}\]
<pre><code class=language-julia >slz &#61; dot&#40;k,p‚ÇÄ&#91;2:end&#93;&#41;</code></pre><pre><code class="plaintext code-output">286.45833333333826</code></pre>
<p>che corrisponde alla soluzione esatta 6875/24:</p>
<pre><code class=language-julia >6875/24</code></pre><pre><code class="plaintext code-output">286.4583333333333</code></pre>
<h3 id=tutto_insieme ><a href="#tutto_insieme" class=header-anchor >Tutto insieme</a></h3>
<p>Qui ora riuniamo tutti i passaggi sopra esposti all&#39;interno di un&#39;unica funzione ordinata. Possiamo anche effettuare qualche piccola ottimizzazione, per esempio definendo la matrice \(P\) come sparsa, grazie alle strutture importate con <code>SparseArrays</code>, in modo da potenzialmente diminuire il consumo di memoria.</p>
<pre><code class=language-julia >function F&#40;nbowls, nballs; verbose&#61;false, plot_graph&#61;false&#41;
	if verbose println&#40;&quot;Deriving states and initial probabilities&quot;&#41; end
	states, p‚ÇÄ &#61; get_states&#40;nbowls, nballs&#41;
	states_dict &#61; Dict&#40;state &#61;&gt; i for &#40;i, state&#41; in enumerate&#40;states&#41;&#41;
	nstates &#61; length&#40;states&#41;
	P &#61; spzeros&#40;nstates, nstates&#41;
	if verbose println&#40;&quot;Assembling transition matrix P&quot;&#41; end
	for st in states
		if &#33;is_absorbing&#40;st&#41;
			for i in 1:nbowls
				if st&#91;i&#93; &gt; 0
					# where can the current ball move?
					# can move with direction -1
					st_new_m1 &#61; copy&#40;st&#41;
					st_new_m1&#91;i&#93; -&#61; 1; st_new_m1&#91;mod1&#40;i-1,nbowls&#41;&#93; &#43;&#61;1 # move by -1
					st_new_m1 &#61; min_state&#40;st_new_m1&#41; # retrieve minimal configuration
					# or with direction 1
					st_new_p1 &#61; copy&#40;st&#41;
					st_new_p1&#91;i&#93; -&#61; 1; st_new_p1&#91;mod1&#40;i&#43;1,nbowls&#41;&#93; &#43;&#61;1 # move by &#43;1
					st_new_p1 &#61; min_state&#40;st_new_p1&#41; # retrieve minimal configuration
					# update P matrix entries
					P&#91;states_dict&#91;st&#93;,states_dict&#91;st_new_m1&#93;&#93; &#43;&#61; st&#91;i&#93;
					P&#91;states_dict&#91;st&#93;,states_dict&#91;st_new_p1&#93;&#93; &#43;&#61; st&#91;i&#93;
				end
			end
		else
			P&#91;states_dict&#91;st&#93;,states_dict&#91;st&#93;&#93; &#61; 1
		end
	end
	# normalize the matrix by dividing each value by the sum of its row values
	for i in 1:size&#40;P&#41;&#91;1&#93;
		P&#91;i,:&#93; &#61; P&#91;i,:&#93;/sum&#40;P&#91;i,:&#93;&#41;
	end
	if plot_graph
		println&#40;&quot;Plotting MC graph&quot;&#41;
		graphplot&#40;P,
		names&#61;join.&#40;states&#41;,
		nodesize &#61; 0.2,
		curvature_scalar&#61;0.1,
		node_shape&#61;:circle,
		# edge_label &#61; P,
		# edgelabel_offset &#61; 0,
		fontsize &#61; 4,
		self_edge_size &#61; 0.12,
		method&#61;:circular,
		axis_buffer&#61;0.2&#41;
	end
	Q &#61; P&#91;2:end,2:end&#93;
	if verbose println&#40;&quot;Solving the linear system&quot;&#41; end
	if size&#40;Q&#41;&#91;1&#93; &gt; 1
		# k &#61; bicgstabl&#40;I&#40;nstates-1&#41;-Q, ones&#40;nstates-1&#41;&#41;
		k &#61; &#40;I&#40;nstates-1&#41;-Q&#41;\ones&#40;nstates-1&#41;
	else
		k &#61; &#91;1/&#40;I&#40;nstates-1&#41;-Q&#41;&#91;1&#93;&#93;
	end
	slz &#61; dot&#40;k,p‚ÇÄ&#91;2:end&#93;&#41;
	if verbose println&#40;&quot;done&#33;&quot;&#41; end
	return slz
end

function G&#40;N,M&#41;
	S &#61; 0
	for n in 2:N, m in 2:M
		println&#40;&quot;&#40;n,m&#41;&#61;&#40;&#36;n,&#36;m&#41;&quot;&#41;
		@time S &#43;&#61; F&#40;n,m&#41;
		println&#40;&quot;&quot;&#41;
	end
	println&#40;&quot;done&#33;&quot;&#41;
	return S
end

# G&#40;12,12&#41; risolve il problema
G&#40;4,4&#41;; # giusto un esempio</code></pre><pre><code class="plaintext code-output">(n,m)=(2,2)
  0.000078 seconds (244 allocations: 10.453 KiB)

(n,m)=(2,3)
  0.000046 seconds (273 allocations: 11.531 KiB)

(n,m)=(2,4)
  0.000143 seconds (478 allocations: 34.625 KiB)

(n,m)=(3,2)
  0.000026 seconds (383 allocations: 15.688 KiB)

(n,m)=(3,3)
  0.000035 seconds (770 allocations: 45.953 KiB)

(n,m)=(3,4)
  0.000053 seconds (1.04 k allocations: 58.336 KiB)

(n,m)=(4,2)
  0.000077 seconds (816 allocations: 51.422 KiB)

(n,m)=(4,3)
  0.000068 seconds (1.39 k allocations: 79.086 KiB)

(n,m)=(4,4)
  0.000130 seconds (2.66 k allocations: 145.102 KiB)

done!
</code></pre>
<pre><code class=language-julia >@time F&#40;10,10&#41; # altro esempio di quanto ci mette il codice con n ed m alti</code></pre><pre><code class="plaintext code-output">  3.991362 seconds (9.92 M allocations: 4.505 GiB, 14.03% gc time, 0.58% compilation time)
1.0595539091379317e9</code></pre>

<script src="https://giscus.app/client.js"
		data-repo="federicomor/federicomor.github.io"
		data-repo-id=R_kgDOLBdBYA 
		data-category=Announcements 
		data-category-id=DIC_kwDOLBdBYM4Clm0M 
		data-mapping=url 
		data-strict=0 
		data-reactions-enabled=1 
		data-emit-metadata=0 
		data-input-position=bottom 
		data-theme=preferred_color_scheme 
		data-lang=it 
		// data-loading=lazy  crossorigin=anonymous 
		async>
</script>

<div class=page-foot >
    
    Last modified: March 30, 2025. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the lovely <a href="https://julialang.org">Julia programming language</a>.
</div>
</div>
    </div>  
    
        <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/contrib/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>